I"É‘<p>This is a continuation of my <a href="http://letsmakerobots.com/node/39996">Robot Metallurgy 101 ‚Äì AVR Lesson Journal</a></p>

<ul>
  <li><a href="https://github.com/Ladvien/ATtiny1634_AVR_Code">USART_1634 Code Github</a></li>
</ul>

<p>I started looking through Newbie Hack‚Äôs tutorials on AVR trying to work up the energy to tackle <a href="http://www.newbiehack.com/MicrocontrollersABeginnersGuideOurFirstLCDProgram.aspx">First LCD Program</a>.  Many don‚Äôt know this, but I <em>despise</em> workings with LCDs.  I think it is two parts, one, I live in a world with high-resolution screens embedded in everything from <a href="http://www.goodfood.com.au/photogallery/good-food/home-coffee-machine-road-test-20130304-2ffma.html?aggregate=&amp;selectedImage=2">coffee-machines</a> to <a href="https://www.google.com/search?q=high+resolution+screen+on+toilet&amp;sa=X&amp;rlz=2C2OPRA_enUS0538US0538&amp;tbm=isch&amp;tbo=u&amp;source=univ&amp;ei=SVMSU_r3N8nlyAHXqYCAAQ&amp;ved=0CGsQsAQ&amp;biw=1342&amp;bih=556#q=toliet+with+screen&amp;tbm=isch&amp;facrc=_&amp;imgdii=_&amp;imgrc=-CVkeG8NeiqIeM%253A%3BJjCd_KvddwpmGM%3Bhttp%253A%252F%252F25.media.tumblr.com%252Ftumblr_mb84no1XCV1ruylkdo1_1280.jpg%3Bhttp%253A%252F%252Feveryinteraction.tumblr.com%252Fpost%252F32674222735%252Frate-my-toilet-touch-screen-on-exit-to-singapore%3B1280%3B960">toilets</a>.  Trying to settle with an old school LCD doesn‚Äôt cut it for me.  Furthermore, wiring a non-serial interface LCD is a ever loving pain.</p>

<p>But looking at the rest of the Newbie Hack tutorials I knew I would need some way to display information from the ATtiny1634.  I thought about it and compromised: I‚Äôd focus on UART next.  That way I could display information on my desktop screen.</p>

<p>I began reading about UART on AVR; here are some of the good ones I found,</p>

<ol>
  <li>Newbie Hack‚Äôs <a href="http://www.youtube.com/watch?v=U1kr9gYviMc">One Way Communication</a></li>
  <li>Newbie Hack‚Äôs <a href="http://www.youtube.com/watch?v=dkAbPzzn2K4">Two way Communication</a></li>
  <li>maxEmbedded‚Äôs <a href="http://maxembedded.com/2013/09/30/the-usart-of-the-avr/">USART</a></li>
</ol>

<p>After reading the articles I opened up the ATtiny1634 datasheet and decided I would start by trying to output ‚ÄúALABTU‚Äù to a serial-port into <a href="http://realterm.sourceforge.net/">Real Term</a>.</p>

<p>It took me maybe an hour or two to get something working; here is what I learned along the way.</p>

<p><strong>1. AVR UART is Easy.</strong></p>

<p>The following code sets the baud rate on the ATtiny 1634 using the UBBR chart from the datasheet, then, transmits the letter ‚ÄúA.‚Äù</p>

<p><strong>UART Code v01</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">//</span>
<span class="c1">// UART Example on the ATtiny1634 using UART0.</span>
<span class="c1">// C. Thomas Brittain</span>
<span class="c1">// letsmakerobots.com</span>

<span class="cp">#define F_CPU 8000000    // AVR clock frequency in Hz, used by util/delay.h
#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;
</span><span class="c1">// define some macros</span>
<span class="cp">#define UBBR 51 // 9600, .02%
</span>
<span class="c1">// function to initialize UART</span>
<span class="kt">void</span> <span class="nf">uart_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Set baud rate */</span>
	<span class="n">UBRR0H</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">UBBR</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">UBRR0L</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">UBBR</span><span class="p">;</span>
	<span class="cm">/* Enable receiver and transmitter */</span>
	<span class="n">UCSR0B</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXEN0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">TXEN0</span><span class="p">);</span>
	<span class="cm">/* Set frame format: 8data, 1stop bit */</span>
	<span class="n">UCSR0C</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">USBS0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">UCSZ00</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">UCSZ01</span><span class="p">);</span>   <span class="c1">// 8bit data format</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">USART_Transmit</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Wait for empty transmit buffer */</span>
	<span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span> <span class="n">UCSR0A</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">UDRE0</span><span class="p">))</span> <span class="p">);</span>

	<span class="cm">/* Put data into buffer, sends the data */</span>
	<span class="n">UDR0</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">uart_init</span><span class="p">();</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>

		<span class="n">USART_Transmit</span><span class="p">(</span><span class="mh">0x41</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<ul>
  <li>
    <p><strong>Line 10:</strong> This creates a macro for the UART Baud Rate Register (UBBR).  This number can be calculated using the formula on page 148 of the <a href="http://www.atmel.com/Images/Atmel-8303-8-bit-AVR-Microcontroller-tinyAVR-ATtiny1634_Datasheet.pdf">datasheet</a>.  It should be: UBBR = ((CPU_SPEED)/16<em>DESIRED_BAUD)-1.  For me, I wanted to set my rate to 9600, therefore: UBBR = (8,000,000/16</em>9600)-1; Or: UBBR = (8,000,000/153,600)-1 = **51.083.  **It can have a slight margin of error, and since we can‚Äôt use a float, I rounded to 51.<img src="../images/BAUD_CALC.png" alt="" /></p>
  </li>
  <li>
    <p>We then setup of function to initialize the UART connection.  <strong>Lines 16-17</strong> load our calculated baud rate into a register that will actually set the speed we decided upon.  This is done by using four bits from the UBBR0L and UBBR0H registers.  If the¬†¬ª is unfamiliar to you, it is the <a href="http://www.cprogramming.com/tutorial/bitwise_operators.html">right-shift operator</a> and works much like the left-shift, but yanno, in the other direction.</p>
  </li>
  <li>
    <p>Still in initialization, <strong>line 19</strong> enables both the RX0 and the TX0 pins (PA7 and PB0 respectively).  I‚Äôm not using the TX0 pin yet, but I figured I might as well enable it since I‚Äôll use it later.<img src="../images/TX_RX_EN.png" alt="" /></p>
  </li>
  <li>
    <p><strong>Line 21</strong> sets the bits to tell the Tiny1634 what sort of communication we want.  We want 8 bit, non-parity, 1 stop bit.  Enabling USBS0, UCSZ00 and UCSZ01 give us these values.<img src="../images/UCSR2.png" alt="" />.</p>
  </li>
  <li>
    <p><strong>Line 24</strong> is the beginning of the function that‚Äôll transmit our data.  <strong>Line 27</strong> checks to see if the ATtiny1634 is finished transmitting before giving it more to transmit.  The UDRE0 is a bit on the UCSR0A register that is only clear when the transmit buffer is clear.  So, the <strong>while ( !(UCSR0A &amp; (1¬´UDRE0));</strong> checks the bit, if it is not clear, it checks it again, and again, until it is.  This is a fancy pause, which is dependent on the transmit buffer being clear.  <strong>Line 30</strong> is where the magic happens.  The UDR0 is the transmit register, whatever is placed in the register gets shot out the TX line.  Here, we are passing the data that was given to the USART_Transmit function when it is called.</p>
  </li>
  <li>
    <p><strong>Line 39</strong> is passing the hex value for the character ‚ÄúA‚Äù to the transmit function.</p>
  </li>
</ul>

<p>This was a bit easier than expected.</p>

<p>Here was the output from Code v01.</p>

<p><img src="../images/ATtiny1634_A_0.png" alt="" /></p>

<p>After a little more tweaking and watching Newbie Hack‚Äôs video on <a href="http://newbiehack.com/MicrocontrollersABeginnersGuidePassingaStringtotheLCD.aspx">sending strings to an LCD</a>, I adapted NH‚Äôs code to be used by my UART_Transmit() function I ended with a full string of ‚ÄúALABTU!‚Äù on the serial monitor.</p>

<p>I did this by creating a function called <strong>Serial_Print,</strong> which is passed a character array (string). <strong>StringOfCharacters</strong> is a <a href="http://pw1.netcom.com/~tjensen/ptr/ch1x.htm">pointer</a> and will be passing each character to the UART transmission.  Pointers are simply variables that point to the contents of other variables.  They are highly useful when you are looking at the information contained in a variable rather than changing variables‚Äô data.  Newbie Hack did an excellent job explaining <a href="http://youtu.be/6yi8RZmXvh0?t=4m25s">pointers</a>.</p>

<p>Now, whenever the <strong>Serial_Print</strong> function is called it starts the loop contained.  The loop (<strong>line 60, code v02</strong>) continues to point out each value contained in the string <em>until</em> it comes across a ‚Äú0‚Äù at which point it exits the loop, and subsequently, the function call.</p>

<p><strong><a href="https://github.com/Ladvien/ATtiny1634_AVR_Code/blob/master/Attiny1634_UART_Code_Evolution/ATtiny1634_UART_Code_v02.c">UART Code v02</a></strong></p>

<p>The above code provided the following output in the serial monitor. (ALABTU!)</p>

<p><img src="../images/ATtiny1634_ALABTU_NO_CRLF_0.png" alt="" /></p>

<p>At this point my simple mind was quite pleased with its trite accomplishments and I saw building a library out of my code being pretty easy.  But a few problems I had to solve first:</p>

<p><strong>A. Dynamic baud rate initialization.</strong></p>

<p>In Arduino C <strong>Serial.begin(9600)</strong> initializes the serial connection and sets the baud rate.  This is dynamic regardless of running an Arduino Uno at 1mhz or Arduino Mega at 16mhz.  I wanted the same functionality; being able to set the baud rate by passing it to the intialization function, <strong>uart_init()</strong>.</p>

<p>I solved this by adding the formula in the <strong>uart_init()</strong> function (see <strong>lines 21 and 38 of code v03</strong>).  In short, the F_CPU macro contains whatever speed the microcontroller is set, in my case 8mhz, and the user knows what baud rate he wants the code set, so I had all the pieces for to solve the UBBR equation.  I made F_CPU part of the calculation and allowed the uart_init() to pass the desired baud rate to the formula.  This allowed me to set the baud rate simply by passing the uart_init() function whatever baud rate I wanted. e.g., <strong>uart_init(9600);</strong></p>

<p><strong>B. Carriage-return and line-feed at end-of-transmission (EOT).</strong></p>

<p>In Arduino C every time you send serial data, <strong>Serial.print(‚ÄúWhat‚Äôs up mother blinkers!?‚Äù)</strong>, there are two characters added.  If you are as new to the world of microcontrollers as me, you may have had headaches finding where these extra characters came from whenever you printed something serially.  Arduino C‚Äôs <strong>Serial.Print()</strong> function automatically adds the carriage-return and line-feed characters.  In <a href="http://www.asciitable.com/">ASCII</a> that‚Äôs, ‚Äú13‚Äù and ‚Äú10‚Äù and in hex, ‚Äú0x0A‚Äù and ‚Äú0x0D‚Äù respectively.  Arduino C does this, I believe, as a protocol flagging the end of a transmission.  This is helpful for the serial receiver to parse the data.</p>

<p>To solve this I simply created two functions <strong>CR()</strong> and <strong>LF()</strong> that would transmit the hex code for the line-feed character and the carriage-return.  I went this route because not <em>every</em> serial devices excepts them, for instance, the HM-10 that I‚Äôm in a love-hate with excepts no characters following the AT commands you send it.  I wanted an easy way to send these characters, but not so embedded I had to pull my hair out trying <strong>not</strong> to send them.</p>

<p>The following code is what I ended with,</p>

<p><strong><a href="https://github.com/Ladvien/ATtiny1634_AVR_Code/blob/master/Attiny1634_UART_Code_Evolution/ATtiny1634_UART_Code_v03.c">UART Code v03</a></strong></p>

<p>The above code provided the following output.  Notice my serial monitor automatically recognized the CR and LF character, which is why ‚ÄúALABTU!‚Äù is one per line, and always left-justified.  <strong>Booyah!</strong></p>

<p><img src="../images/ATtiny1634_ALABTU_WITH_CRLF.png" alt="" /></p>

<p>Ok.  I‚Äôm not done yet, here is what I‚Äôll be working on in the evening over the next few days,</p>

<p>Receiving data is a little more complex‚Ä¶<em>a little.</em></p>

<p><strong>2. RX is less easy</strong></p>

<p>I started by reviewing Newbie Hack‚Äôs code <a href="http://newbiehack.com/UART-OneWay-ChipToChip.aspx">One Way Communication from Chip-to-Chip</a>, more specifically, his code about the receiving chip.  I skipped the part about intilization, since I‚Äôd already done that and went straight to his receiving code,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="n">include</span> <span class="o">&lt;</span><span class="n">avr</span><span class="o">/</span><span class="n">io</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DDRB</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">);</span>

	<span class="c1">//Communication UART specifications (Parity, stop bits, data bit length)</span>
	<span class="kt">int</span> <span class="n">UBRR_Value</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span> <span class="c1">//This is for 2400 baud</span>
	<span class="n">UBRR0H</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="p">(</span><span class="n">UBRR_Value</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">UBRR0L</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">UBRR_Value</span><span class="p">;</span>
	<span class="n">UCSR0B</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RXEN0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">TXEN0</span><span class="p">);</span>
	<span class="n">UCSR0C</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">USBS0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="n">UCSZ00</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">receiveData</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">UCSR0A</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RXC0</span><span class="p">))</span> <span class="p">);</span>

		<span class="n">receiveData</span> <span class="o">=</span> <span class="n">UDR0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">receiveData</span> <span class="o">==</span> <span class="mi">0</span><span class="n">b11110000</span><span class="p">)</span> <span class="n">PORTB</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This code receives data and turns on/off a LED if anything was received.  It doesn‚Äôt concern itself with the values received, just whether <em>something</em> was received.</p>

<p>I was able to replicate this code and get the LED to switch states, but I quickly noticed a problem.  The <strong>While</strong> loop on <strong>line 16</strong> is stuck in checking to see if anything has been received, continuously.  The problem is apparent; this freezes the microcontroller from doing anything else.  Damnit.</p>

<p>Alright, need a different solution; sadly, the solution was something I‚Äôd been avoiding for a year, the use of <a href="http://en.wikipedia.org/wiki/Interrupt">interrupts</a>.</p>

<p>I‚Äôm not the sharpest when it comes to electronics, before July 2012 all I‚Äôd ever done with electronics was turned‚Äôem on and checked Facebook. (By the way, <strong>up yours Facebook.</strong><strong>)</strong>  Since my hardware education began I‚Äôve avoided learning about interrupts because they‚Äôve intimidated me.</p>

<p>I won‚Äôt go into interrupts here, since I‚Äôm just learning about them.  But I‚Äôll mention there are two types, <a href="http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;t=89843&amp;start=all&amp;postdays=0&amp;postorder=asc">internal and external</a>.</p>

<p>Internal interrupts are generated by the internal hardware of a microcontroller and are called <strong>software interrupts,</strong> because they are genereated by the CPU as a result of how it is coded.  <strong>External interrupts</strong> are voltages delivered to a pin on the microcontroller.  Also, interrupts essentially cause the CPU to put a bookmark in the code it was reading, run over and take care of whatever, then when finished, come back to the bookmarked code and continues reading.</p>

<p><img src="http://upload.wikimedia.org/wikibooks/en/thumb/9/9f/Interrupt.svg/467px-Interrupt.svg.png" alt="" /></p>

<p>That stated, I‚Äôd refer you to Newbie Hack‚Äôs tutorials on <a href="http://www.newbiehack.com/IntroductiontoInterrupts.aspx">AVR interrupts</a>.  It‚Äôs excellent.  Also, <strong>Abcminiuser</strong> over at AVR Freaks provided an <a href="http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;t=89843&amp;start=all&amp;postdays=0&amp;postorder=asc">excellent tutorial</a> on AVR interrupts.</p>

<p>Ok. Back to my problem.</p>

<p>So, I dug in the <a href="http://www.atmel.com/Images/Atmel-8303-8-bit-AVR-Microcontroller-tinyAVR-ATtiny1634_Datasheet.pdf">ATtiny1634 datasheet</a> (pg 168) and found the ATtiny1634 has an interrupt that will fire whenever the RX data buffer is full.  To activate this interrupt we have to do two things, enable global interrupts and set the RXCIE0 bit on the UCSR0B register.  This seemed pretty straight forward, but I found a <a href="http://www.avrfreaks.net/?name=PNphpBB2&amp;file=viewtopic&amp;t=48188">AVR Freaks tutorial</a> that helped explain it anyway.</p>

<p><strong>Caveat</strong>, I‚Äôm learning to re-read which register a bit is found.  Occasionally, I‚Äôm finding myself frustrated a piece of code is not working, only to realize I‚Äôm initializing a bit on an incorrect port.  For example, <code class="highlighter-rouge">UCSR0D |= (1&lt;&lt;RXCIE0)</code> will compile fine, but it would actually be enabling the bit RXSEI, which is the bit you set to enable an interrupt at the <em>start</em> of a serial data receive.  This happens because the names of registers and bits are part of the AVR Core library, but they are simply macros for numbers.  In the case of RXCIE0, it actually represents 7, so coding <code class="highlighter-rouge">UCSR0D |= (1&lt;&lt;RXCIE0)</code> is simply setting the 7th bit on the <strong>wrong register</strong>.  Not that I did that or something.</p>

<p>Alright, I now have the interrupt setup for when the ATtiny1634 is <em>done</em> receiving a byte.</p>

<p><strong><a href="https://github.com/Ladvien/ATtiny1634_AVR_Code/blob/master/Attiny1634_UART_Code_Evolution/ATtiny1634_UART_Code_v04.c">UART Code v04</a></strong></p>

<p>Of course, I didn‚Äôt add a character to character array conversion, yet.  I‚Äôm not sure if I want to add this to current function.  I personally would rather handle my received characters on a project specific basis.  But it should really be as simple as adding character array, then a function to add each character received to the array until it is full.  Then, decide what to do when the character array is full.</p>

<p>But Code v04 gave me the following output:</p>

<p><img src="../images/ATtiny1634_ALABTU_WITH_RXI.png" alt="" /></p>

<p>Each time the letter ‚ÄúA‚Äù is sent from the serial terminal a RX interrupt event occurs.  The interrupt transfers the byte to a variable that is then sent right back out by the Serial_Print() function.  Thus, echoing the data you send it.</p>

<p><strong>3. Fully Interrupted</strong></p>

<p>Ok, so, interrupts are a little tricky.  Well, one trick.  <strong>When you are using an interrupt that modifies a variable anywhere else your main that modifies the same variable, you‚Äôll need to disable the interrupt before the modification.</strong>  It prevents corrupt or incomplete data.</p>

<p>Also, I am using a poor man‚Äôs buffer.  It‚Äôs a simple buffer that overwrites itself and requires an end-of-transmission character, in my case, a ‚Äú.‚Äù from the transmitter to know where to cap the buffer.  Still, I believe this will work for a lot of what I‚Äôd like to use it.</p>

<p>I do foresee a problem when I enable the second UART on the Tiny1634, since really, only one RX interrupt can run the show.  We‚Äôll see.  I‚Äôm a little tired to detail things here, but here is the code I ended with and I tried to comment the hell out of it.</p>

<p><strong><a href="https://github.com/Ladvien/ATtiny1634_AVR_Code/blob/master/Attiny1634_UART_Code_Evolution/ATtiny1634_UART_Code_v05.c">UART Code v05</a></strong></p>

<p>One of the other things I did was enable the sleep mode on the Tiny1634.  It is setup on line 39 and part of the main loop.  It wakes on receiving serial data.  I‚Äôve not tested the power consumption, but this is <em>supposed</em> to make the <strong>chip drop down to ~5uA.</strong></p>

<p>Nifty right? :)</p>

<p>Ok, code for the second UART.</p>

<p><a href="https://github.com/Ladvien/ATtiny1634_AVR_Code/blob/master/Attiny1634_UART_Code_Evolution/ATtiny1634_UART_Code_v06.c">UART Code v06</a></p>

<p><img src="../images/UART0_TO_UART1_ATTINY1634.png" alt="" /></p>

<p>I was surprised.  The interrupts didn‚Äôt seem to trip each other up.  Of course, I only did a simple test of sending data from one terminal into the ATtiny1634 and having it come out on the other terminal.  This would be: Data‚Äì&gt;RX0‚Äî&gt;TX1 and Data‚Äì&gt;RX1‚Äì&gt;TX0</p>

<p>So, there really shouldn‚Äôt be any reason the code would trip out, since the RX0 and RX1 interrupts aren‚Äôt firing at the same time.  I‚Äôll create a library from this code, and as I start using the library in applications I‚Äôll do more debugging and improvement.  Also, if anyone is bored and wants to critique the code, I‚Äôve got my big boy pants on, I‚Äôd appreciate the criticism.</p>

<p>4. <strong>All Together!</strong></p>

<p>It only took me 30 minutes or so to convert the UART code to a library.  Here it is, a UART library consisting of 12 functions.</p>

<ol>
  <li>USART_init0()</li>
  <li>USART_init1()</li>
  <li>USART_Transmit0()</li>
  <li>USART_Transmit1()</li>
  <li>Serial_Print0()</li>
  <li>Serial_Print1()</li>
  <li>ClearBuffer0();</li>
  <li>ClearBuffer1();</li>
  <li>LF0()</li>
  <li>LF1()</li>
  <li>CR0()</li>
  <li>CR1()</li>
</ol>

<p>Functions numbered 0 relate to serial lines 0, which are pins PA7 (Rx0) and PB0 (Tx0).  The functions numbered 1 are serial lines 1, which are pins PB1 (Rx1) and PB2 (Tx1).</p>

<p><strong>USART_init</strong></p>

<ul>
  <li><strong>Initializes a serial lines.  Enables TX and RX pins, assigns the baud rate, and enables RX interrupt on receive.  It also sets the communication as 8 bit, 1 stop-bit, and non-parity.</strong></li>
</ul>

<p><strong>USART_Transmit</strong></p>

<ul>
  <li><strong>Will transmit a single character.</strong></li>
</ul>

<p><strong>Serial_Print</strong></p>

<ul>
  <li><strong>Prints a string.</strong></li>
</ul>

<p><strong>ClearBuffer</strong></p>

<ul>
  <li><strong>Empties the receiving buffer.</strong></li>
</ul>

<p><strong>LF and CR</strong></p>

<ul>
  <li><strong>Transmit a line-feed or carriage-return character.</strong></li>
</ul>

<p>This is the library code: <strong><a href="https://github.com/Ladvien/ATtiny1634_AVR_Code/blob/master/1634analogWrite.h">1634_UART.h</a></strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#ifndef	UART_1634
#define UART_1634
</span>
<span class="cp">#include &lt;avr/interrupt.h&gt;  //Add the interrupt library; int. used for RX.
</span>
<span class="c1">//Buffers for UART0 and UART1</span>
<span class="c1">//USART0</span>
<span class="kt">char</span> <span class="n">ReceivedData0</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="c1">//Character array for Rx data.</span>
<span class="kt">int</span> <span class="n">ReceivedDataIndex0</span><span class="p">;</span>	<span class="c1">//Character array index.</span>
<span class="kt">int</span> <span class="n">rxFlag0</span><span class="p">;</span>			<span class="c1">//Boolean flag to show character has be retrieved from RX.</span>

<span class="c1">//USART1</span>
<span class="kt">char</span> <span class="n">ReceivedData1</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="c1">//Character array for Rx data.</span>
<span class="kt">int</span> <span class="n">ReceivedDataIndex1</span><span class="p">;</span>	<span class="c1">//Character array index.</span>
<span class="kt">int</span> <span class="n">rxFlag1</span><span class="p">;</span>			<span class="c1">//Boolean flag to show character has be retrieved from RX.</span>

<span class="c1">//Preprocessing of functions.  This allows us to initialize functions</span>
<span class="c1">//without having to put them before the main.</span>
<span class="kt">void</span> <span class="nf">USART_init0</span><span class="p">(</span><span class="kt">int</span> <span class="n">BUADRATE</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">USART_Transmit0</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">Serial_Print0</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">StringOfCharacters</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clearBuffer0</span><span class="p">();</span>

<span class="kt">void</span> <span class="nf">USART_init1</span><span class="p">(</span><span class="kt">int</span> <span class="n">BUADRATE</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">USART_Transmit1</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">Serial_Print1</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">StringOfCharacters</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clearBuffer1</span><span class="p">();</span>

<span class="c1">//EOT characters.</span>
<span class="kt">void</span> <span class="nf">LF0</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">CR0</span><span class="p">();</span>

<span class="c1">//EOT characters.</span>
<span class="kt">void</span> <span class="nf">LF1</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">CR1</span><span class="p">();</span>

<span class="c1">// function to initialize UART0</span>
<span class="kt">void</span> <span class="nf">USART_init0</span><span class="p">(</span><span class="kt">int</span> <span class="n">Desired_Baudrate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//Only set baud rate once.  If baud is changed serial data is corrupted.</span>
	<span class="cp">#ifndef UBBR
</span>	<span class="c1">//Set the baud rate dynamically, based on current microcontroller</span>
	<span class="c1">//speed and the desired baud rate given by the user.</span>
	<span class="cp">#define UBBR ((F_CPU)/(Desired_Baudrate*16UL)-1)
</span>	<span class="cp">#endif
</span>
	<span class="c1">//Set baud rate.</span>
	<span class="n">UBRR1H</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">UBBR</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">UBRR1L</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">UBBR</span><span class="p">;</span>

	<span class="c1">//Enables the RX interrupt.</span>
	<span class="c1">//NOTE: The RX data buffer must be clear or this will continue</span>
	<span class="c1">//to generate interrupts. Pg 157.</span>
	<span class="n">UCSR1B</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXCIE1</span><span class="p">);</span>

	<span class="c1">//Enable receiver and transmitter</span>
	<span class="n">UCSR1B</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXEN1</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">TXEN1</span><span class="p">);</span>

	<span class="c1">//Set frame format: 8data, 1 stop bit</span>
	<span class="n">UCSR1C</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">UCSZ00</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">UCSZ01</span><span class="p">);</span>   <span class="c1">// 8bit data format</span>

	<span class="c1">//Enables global interrupts.</span>
	<span class="n">sei</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Function to initialize UART1</span>
<span class="kt">void</span> <span class="nf">USART_init1</span><span class="p">(</span><span class="kt">int</span> <span class="n">Desired_Baudrate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//Only set baud rate once.  If baud is changed serial data is corrupted.</span>
	<span class="cp">#ifndef UBBR
</span>		<span class="c1">//Set the baud rate dynamically, based on current microcontroller</span>
		<span class="c1">//speed and the desired baud rate given by the user.</span>
		<span class="cp">#define UBBR ((F_CPU)/(Desired_Baudrate*16UL)-1)
</span>	<span class="cp">#endif
</span>
	<span class="c1">//Set baud rate.</span>
	<span class="n">UBRR0H</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">UBBR</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">);</span>
	<span class="n">UBRR0L</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">UBBR</span><span class="p">;</span>

	<span class="c1">//Enables the RX interrupt.</span>
	<span class="c1">//NOTE: The RX data buffer must be clear or this will continue</span>
	<span class="c1">//to generate interrupts. Pg 157.</span>
	<span class="n">UCSR0B</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXCIE0</span><span class="p">);</span>

	<span class="c1">//Enable receiver and transmitter</span>
	<span class="n">UCSR0B</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXEN0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">TXEN0</span><span class="p">);</span>

	<span class="c1">//Set frame format: 8data, 1 stop bit</span>
	<span class="n">UCSR0C</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">UCSZ00</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">UCSZ01</span><span class="p">);</span>   <span class="c1">// 8bit data format</span>

	<span class="c1">//Enables global interrupts.</span>
	<span class="n">sei</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//USART0</span>
<span class="kt">void</span> <span class="nf">USART_Transmit0</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//We have to disable RX interrupts.  If we have</span>
	<span class="c1">//an interrupt firing at the same time we are</span>
	<span class="c1">//trying to transmit we'll lose some data.</span>
	<span class="n">UCSR0B</span> <span class="o">^=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXEN0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXCIE0</span><span class="p">));</span>

	<span class="c1">//Wait for empty transmit buffer</span>
	<span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span> <span class="n">UCSR0A</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">UDRE0</span><span class="p">))</span> <span class="p">);</span>

	<span class="c1">//Put data into buffer, sends the data</span>
	<span class="n">UDR0</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="c1">//Re-enable RX interrupts.</span>
	<span class="n">UCSR0B</span> <span class="o">^=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXEN0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXCIE0</span><span class="p">));</span>

<span class="p">}</span>

<span class="c1">//USART1</span>
<span class="kt">void</span> <span class="nf">USART_Transmit1</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">data</span> <span class="p">)</span>
<span class="p">{</span>

	<span class="c1">//We have to disable RX interrupts.  If we have</span>
	<span class="c1">//an interrupt firing at the same time we are</span>
	<span class="c1">//trying to transmit we'll lose some data.</span>
	<span class="n">UCSR1B</span> <span class="o">^=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXEN1</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXCIE1</span><span class="p">));</span>

	<span class="c1">//Wait for empty transmit buffer</span>
	<span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span> <span class="n">UCSR1A</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">UDRE1</span><span class="p">))</span> <span class="p">);</span>

	<span class="c1">//Put data into buffer, sends the data</span>
	<span class="n">UDR1</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="c1">//Re-enable RX interrupts.</span>
	<span class="n">UCSR1B</span> <span class="o">^=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXEN1</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXCIE1</span><span class="p">));</span>

<span class="p">}</span>

<span class="c1">//This functions uses a character pointer (the "*" before the StringOfCharacters</span>
<span class="c1">//makes this a pointer) to retrieve a letter from a temporary character array (string)</span>
<span class="c1">//we made by passing the function "ALABTU!"</span>

<span class="c1">//USART0</span>
<span class="kt">void</span> <span class="nf">Serial_Print0</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">StringOfCharacters</span><span class="p">){</span>
	<span class="n">UCSR0B</span> <span class="o">^=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXEN0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXCIE0</span><span class="p">));</span>

	<span class="c1">//Let's do this until we see a zero instead of a letter.</span>
	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">StringOfCharacters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>

		<span class="c1">//This function actually sends each character, one by one.</span>
		<span class="c1">//After a character is sent, we increment the pointer (++).</span>
		<span class="n">USART_Transmit0</span><span class="p">(</span><span class="o">*</span><span class="n">StringOfCharacters</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="c1">//Re-enable RX interrupts.</span>
	<span class="n">UCSR0B</span> <span class="o">^=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXEN0</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXCIE0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">//USART1</span>
<span class="kt">void</span> <span class="nf">Serial_Print1</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">StringOfCharacters</span><span class="p">){</span>
	<span class="n">UCSR1B</span> <span class="o">^=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXEN1</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXCIE1</span><span class="p">));</span>

	<span class="c1">//Let's do this until we see a zero instead of a letter.</span>
	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">StringOfCharacters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>

		<span class="c1">//This function actually sends each character, one by one.</span>
		<span class="c1">//After a character is sent, we increment the pointer (++).</span>
		<span class="n">USART_Transmit1</span><span class="p">(</span><span class="o">*</span><span class="n">StringOfCharacters</span><span class="o">++</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="c1">//Re-enable RX interrupts.</span>
	<span class="n">UCSR1B</span> <span class="o">^=</span> <span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXEN1</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">RXCIE1</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">//USART0</span>
<span class="kt">void</span> <span class="nf">clearBuffer0</span><span class="p">(){</span>
	<span class="c1">//Ugh.  A very inefficient way to clear the buffer. :P</span>
	<span class="n">ReceivedDataIndex0</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;)</span>
	<span class="p">{</span>
		<span class="c1">//We set the buffer to NULL, not 0.</span>
		<span class="n">ReceivedData0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//USART1</span>
<span class="kt">void</span> <span class="nf">clearBuffer1</span><span class="p">(){</span>
	<span class="c1">//Ugh.  A very inefficient way to clear the buffer. :P</span>
	<span class="n">ReceivedDataIndex1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;)</span>
	<span class="p">{</span>
		<span class="c1">//We set the buffer to NULL, not 0.</span>
		<span class="n">ReceivedData1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">LF0</span><span class="p">(){</span><span class="n">USART_Transmit0</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">);}</span>  <span class="c1">//Function for sending line-feed character.</span>
<span class="kt">void</span> <span class="nf">CR0</span><span class="p">(){</span><span class="n">USART_Transmit0</span><span class="p">(</span><span class="mh">0x0D</span><span class="p">);}</span>  <span class="c1">//Function for sending carriage-return character.</span>

<span class="kt">void</span> <span class="nf">LF1</span><span class="p">(){</span><span class="n">USART_Transmit1</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">);}</span>  <span class="c1">//Function for sending line-feed character.</span>
<span class="kt">void</span> <span class="nf">CR1</span><span class="p">(){</span><span class="n">USART_Transmit1</span><span class="p">(</span><span class="mh">0x0D</span><span class="p">);}</span>  <span class="c1">//Function for sending carriage-return character.</span>

<span class="n">ISR</span><span class="p">(</span><span class="n">USART0_RX_vect</span><span class="p">){</span>
	<span class="c1">//RX0 interrupt</span>

	<span class="c1">//Show we have received a character.</span>
	<span class="n">rxFlag0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">//Load the character into the poor man's buffer.</span>
	<span class="c1">//The buffer works based on a end-of-transmission character (EOTC)</span>
	<span class="c1">//sent a the end of a string.  The buffer stops at 63 instead of 64</span>
	<span class="c1">//to always give room for this EOTC.  In our case, "."</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ReceivedDataIndex0</span> <span class="o">&lt;</span> <span class="mi">63</span><span class="p">){</span>
		<span class="c1">//Actually pull the character from the RX register.</span>
		<span class="n">ReceivedData0</span><span class="p">[</span><span class="n">ReceivedDataIndex0</span><span class="p">]</span> <span class="o">=</span> <span class="n">UDR0</span><span class="p">;</span>
		<span class="c1">//Increment RX buffer index.</span>
		<span class="n">ReceivedDataIndex0</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="c1">//If the buffer is greater than 63, reset the buffer.</span>
		<span class="n">ReceivedDataIndex0</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">clearBuffer0</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">ISR</span><span class="p">(</span><span class="n">USART1_RX_vect</span><span class="p">){</span>
	<span class="c1">//RX1 interrupt</span>
	<span class="n">PORTA</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA6</span><span class="p">);</span>
	<span class="c1">//Show we have received a character.</span>
	<span class="n">rxFlag1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ReceivedDataIndex1</span> <span class="o">&lt;</span> <span class="mi">63</span><span class="p">){</span>
		<span class="c1">//Actually pull the character from the RX register.</span>
		<span class="n">ReceivedData1</span><span class="p">[</span><span class="n">ReceivedDataIndex1</span><span class="p">]</span> <span class="o">=</span> <span class="n">UDR1</span><span class="p">;</span>
		<span class="c1">//Increment RX buffer index.</span>
		<span class="n">ReceivedDataIndex1</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="c1">//If the buffer is greater than 63, reset the buffer.</span>
		<span class="n">ReceivedDataIndex1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">clearBuffer1</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif</span></code></pre></figure>

<p>Really, it is all the functions moved over to a header file (.h).  One thing I‚Äôll point out, the #ifndef makes sure the header file is not included twice, but I was getting an error with it for awhile, come to find out, you <strong>cannot</strong> start #define name for #ifndef with a number, e.g.,</p>

<ol>
  <li>#ifndef 1634_UART ‚Äì This will not work.</li>
  <li>#ifndef UART_1634 ‚Äì Works great!</li>
</ol>

<p>Eh.  Devil‚Äôs in the details.</p>

<p>Ok, here is a program that utilizes the library.</p>

<p><strong><a href="https://github.com/Ladvien/ATtiny1634_AVR_Code/blob/master/UART_Example.c">Code v07</a></strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// UART Example on the ATtiny1634 using UART0.</span>
<span class="c1">// C. Thomas Brittain</span>
<span class="c1">// letsmakerobots.com</span>
<span class="cp">#define F_CPU 8000000UL		//AVR clock frequency in Hz, used by util/delay.h
#include &lt;avr/io.h&gt;			//Holds Pin and Port defines.
#include &lt;util/delay.h&gt;		//Needed for delay.
#include &lt;avr/sleep.h&gt;		//Needed for sleep mode.
#include "1634_UART.h"
</span>
<span class="c1">// Main</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//Setup received data LED.</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA6</span><span class="p">);</span>

	<span class="c1">//Light LED on PA6 to show the chip has reboot.</span>
	<span class="n">PORTA</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA6</span><span class="p">);</span>
	<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
	<span class="n">PORTA</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA6</span><span class="p">);</span>

	<span class="c1">//Initialize the serial connection and pass it a desired baud rate.</span>
	<span class="n">USART_init0</span><span class="p">(</span><span class="mi">19200</span><span class="p">);</span>
	<span class="n">USART_init1</span><span class="p">(</span><span class="mi">19200</span><span class="p">);</span>

	<span class="c1">//Set Sleep</span>
	<span class="n">set_sleep_mode</span><span class="p">(</span><span class="n">SLEEP_MODE_IDLE</span><span class="p">);</span>

	<span class="c1">//Forever loop.</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
		<span class="c1">//ReceivedData = "ASDASDAS";</span>
		<span class="n">sleep_mode</span><span class="p">();</span>

		<span class="c1">//USART0</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ReceivedData0</span><span class="p">[(</span><span class="n">ReceivedDataIndex0</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mh">0x2E</span><span class="p">){</span>
			<span class="c1">//Function to print the RX buffer</span>
			<span class="n">Serial_Print1</span><span class="p">(</span><span class="n">ReceivedData0</span><span class="p">);</span>
			<span class="c1">//Let's signal the end of a string.</span>
			<span class="n">LF1</span><span class="p">();</span><span class="n">CR1</span><span class="p">();</span> <span class="c1">//Ending characters.</span>
			<span class="c1">//After we used the data from buffer, clear it.</span>
			<span class="n">clearBuffer0</span><span class="p">();</span>
			<span class="c1">//Reset the RX flag.</span>
			<span class="n">rxFlag0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">//USART1</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ReceivedData1</span><span class="p">[(</span><span class="n">ReceivedDataIndex1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mh">0x2E</span><span class="p">){</span>
			<span class="c1">//Function to print the RX buffer</span>
			<span class="n">Serial_Print0</span><span class="p">(</span><span class="n">ReceivedData1</span><span class="p">);</span>
			<span class="c1">//Let's signal the end of a string.</span>
			<span class="n">LF0</span><span class="p">();</span><span class="n">CR0</span><span class="p">();</span> <span class="c1">//Ending characters.</span>
			<span class="c1">//After we used the data from buffer, clear it.</span>
			<span class="n">clearBuffer1</span><span class="p">();</span>
			<span class="c1">//Reset the RX flag.</span>
			<span class="n">rxFlag1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>


	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This program is the same as above, but using the library.  It simply takes data receiving from one UART and send its out the other.</p>

<p>Alright, that‚Äôs enough UART for awhile.  I might update this when I run into bugs, <strong>which I will, I am a hack.</strong> So, use this code at your own risk of frustration.</p>

<p><strong>Stuff I‚Äôd no energy to finish.</strong></p>

<ol>
  <li>Implement a <a href="http://en.wikipedia.org/wiki/Circular_buffer">circular-buffer</a> (if I get smart enough to do it, that is).</li>
  <li>At least making the buffer size user definable. :)</li>
</ol>
:ET