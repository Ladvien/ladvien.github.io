---
layout: article
title: TinySafeBoot, Arduino, and Wireless Upload to ATtiny85
categories: robots
excerpt:
tags: [robots]
color: "#152a55"
image:
  feature: tsb_logo.png
  teaser: tsb_logo.png
  thumb:
comments: true
---

### The Dream

For awhile now I've dreamt of a PCB which would have everything I need on it: uC, H-bridges, PSU, Lipo charger, inductive power collector, _and_ a wirelesss device which would allow wireless uploading to the uC.  

A lot of failed attempts, some as long as writing my own uploader for the LPC1114, others as "simple" as hacking away at the Arduino IDE source.  However, I finally found a winning combination: TinySafeBoot, Arduino IDE, and most Atmega and ATtiny Atmel chips.

### TinySafeBoot

TinySafeBoot is a pretty neat GPL project which is around 500 bytes.  It allows for selecting of any two pins as RX / TX for two-wire communication.  Or! It has a one-wire protocol.

[TinySafeBoot](http://jtxp.org/tech/tinysafeboot_en.htm)

The part which makes TSB such a great choice for wireless bootloading is its serial communication protocol.  Unlike the hardware protocol Arduino uses, serial communication allows the remote device to control the bootloaders workflow without flipping any hardware pins.  Contrast this against the Arduino bootloader (I think it's optiboot now?) which focuses on resetting the device repeatedly to activate the bootloader.

The hardware doesn't work well is there is no quick way to flip pins on my focused (cheap) wireless devices, the HM-1X and ESP8266.  This means the remote device will have difficulty putting the target uC into bootloader mode.

Of course, TSB has other great features like auto-bauding and password protection, etc.  It's not perfect, but I like it for its simplicity.

### Getting TSB Setup

I have tested TSB on three devices, the ATtiny85, ATmega328P, and ATtiny1634.  _However, I've also tested on an ATtiny1634 which didn't work._

There are two parts to TSB,

1. Firmware
2. [Software](http://jtxp.org/tech/tinysafeboot_en.htm)

However, we are going to only download the software since it allows you to generate "custom" firmware for whatever chip you are targeting.

<a href="http://jtxp.org/tech/tinysafeboot_en.htm"><img src="/images/TSB_software_click.PNG"></a>

From here on I will be demonstrating getting TSB going on an ATtiny85.

#### ISP

First, you will need an AVR ISP.  Long ago I bought an AVR-ISP MKII which I used in combination with Atmel Studio 7.  This will allow us to burn the bootloader and set the fuses.  If you do not have an official AVR-ISP you can use AVRdude through the Arduino IDE.  You can also use an Arduino as an ISP programmer.

So, either,

1. [AVR ISP MKII](http://www.atmel.com/tools/AVRISPMKII.aspx)
2. [Atmel Studio 7](http://www.atmel.com/Microsite/atmel-studio/)

Or

1. [Arduino IDE](https://www.arduino.cc/en/Main/Software)
2. [Arduino Uno ISP](https://www.arduino.cc/en/Tutorial/ArduinoISP)

Either way, once you have your ISP setup you will connect it to the ATtiny85 like,

![](/images/attiny85_soic.png)

One part which is not clear in the above breadboard.  There is a momentary switch connected in series with the RESET pin,

`PB5<--->Switch<--->GND`

This will allow you to easily reset the ATtiny85, which is needed to put the TSB into bootloader mode.

Notice the RX / TX will.  They are not part of the ISP.  They will be our bootloader's TX / RX pins when the bootloader has been burnt.

#### Bootloader Creation

Now, to generate the bootloader.

If you haven't, download the software, extract it to a workspace, and open that workspace in the command-line.  The TSB software is CLI only.

Now enter the following,

`C:\TSB_workspace>tsb tn85 b3b4`

TSB then should generate a hex file titled something like,

`tsb_tn85_b3b4_20150826.hex`

This hex file will be our bootloader customized for our particular AVR, the ATtiny85.

To breakdown the TSB command,

* `tn85` tells the TSB SW you are looking to install this firmware on an ATtiny85. If you need to look up a chip code you can find it in a file in the TSB workspace titled "devices.txt"
* `b3b4` tells the TSB SW you want to use PB3 as RX and PB4 as TX.  I chose these as pins since they are not being used by the ISP.  _Note_, having the ISP and UART connected to the same pins _will_ cause problems.

#### Bootloader Burning

To burn the newly generated bootloader you will need to have your ISP connected to the ATtiny85.  First, check the fuses of your chip.  You need to have the following fuses set according to the TSB website,

*ATtinys:*

* SELFPRGEN must be set to enable flash writes from firmware, e.g. TSB
* BODLEVEL should be set to avoid flash corruption during unsafe device power-up.
* LOCKBITS may be set to MODE 3 for enhanced security (i.e. serious password protection intended).

*ATmegas:*

* BOOTRST activated lets the MCU jump into the Bootloader Section (rather than $0000) with every hardware Reset.
* BODLEVEL should be set to avoid flash corruption during unsafe device power-up.
* BOOTSZ=10 or BOOTSZ=11 to reserve 512 bytes for a Bootloader Section.
* BLB to MODE 2 or 3 protects Bootloader Section from undesirable write access by firmware.
* LOCKBITS may be set to Mode 3 (LB-Mode 3) in a security environment.

Using Atmel studio, go to `Tools-->Device Programming` select your programmer (AVR ISP MKII for me), select the ATtiny85, and hit apply.  Now, go to `Fuses` and make sure they are set to the following for the ATtiny85.

![](/images/ATtiny85_settings.PNG)

If you need to set the fuses using an Arduino-as-ISP, well, I'm not sure I've ever done that, but here's an article that seems legit,

* [Setting Fuses with Arduino-as-ISP and AVRdude](https://dntruong.wordpress.com/2015/07/08/setting-and-reading-attiny85-fuses/)

Once the fuses have been set all that's left is to burn the bootloader.  Using the Atmel approach, go to `Tools--Device Programming` and click on `Device Signature`, this will allow the ISP to see if the chip is ready for uploading.  Once the chip is verified, go to `Memories` and click on the ellipses and select your hex file,

![](/images/burn_tsb.PNG)

Then hit `Program`.  With luck, your bootloader will burn and there will be much rejoicing.

#### Wirelessly uploading

Here's the fun part.  I hooked up my ATtiny85, 2 x HM-10 modules, and an FTDI chip to a PC--like below,

![](/images/TSB_wireless.png)

To see if you everything is working, open a serial terminal program.  I'm a little partial to this one: [HM-1X Aid](https://github.com/Ladvien/HM-1X-Build/raw/master/setup.exe).  Connect the your USB-to-UART using the serial terminal at 9600bps. Once you are connected, press the reset button on your ATtiny85 and send the character `@` from your terminal several times.  If everything is setup correctly the chip should reply with, `TSB` followed by device information.  If it doesn't reply, a few things to check.

1. Test your wireless connection.  For me, I had to make sure the Bluetooth devices had paired and that the Bluetooth device connected to the ATtiny was baud setting was less than 115200.
2. Make sure bootloader was burned correctly.  To test this, connect your ATtiny85 like above, but instead of the Bluetooth devices in the middle, have a USB-to-UART connect to it directly.  Hit reset and send the `@`, which should reply with `TSB`.
3. Make sure your fuses are set correctly.  Especially, `SELFPRGEN` on the ATtiny, since it doesn't come from the factory set.

#### Uploading an Arduino Sketch Wirelessly

Ok, if you were able to get the bootloader to reply wirelessly it's time to test the whole setup.  Open your Arduino and make sure you have install support for the ATtiny85,

* [Arduino IDE and ATtiny Guide](http://highlowtech.org/?p=1695)

Then, in your Arduino IDE select,

* Board: ATtiny
* Processor: ATtiny85
* Clock: 8mhz (internal)

Add this test sketch,

```arduino
void setup() {
  // put your setup code here, to run once:
  for(int i = 0; i < 9; i++){
    pinMode(i, OUTPUT);
  }
}

void loop() {
  // put your main code here, to run repeatedly:
  int pin = 0;
  for(int i = 0; i < 9; i++){
    digitalWrite(i, HIGH);
  }
  delay(500);
  for(int i = 0; i < 9; i++){
    digitalWrite(i, LOW);
  }
  delay(500);
}
```
