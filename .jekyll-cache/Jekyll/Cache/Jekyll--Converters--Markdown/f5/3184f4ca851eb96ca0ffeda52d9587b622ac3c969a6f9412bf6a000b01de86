I"aú<p>Originally posted on <a href="www.letsmakerobots.com">www.letsmakerobots.com</a>
my_uC_icon_5_300x300.png</p>

<p><strong>Not All Those Who Wander are Lost (but I am)</strong></p>

<p>I thought I‚Äôd take some time away from coding my <a href="http://letsmakerobots.com/lpc1114-usb-serial-solution-rerolling-boot-uploader">LPC1114 Uploader</a> and verbally process a few things I‚Äôve learned.  As always, feel free to critique any of it; it‚Äôll only serve to make my code more robust in the end.</p>

<p>This post will be a series of post leading up to the large post I‚Äôll make on writing the uploader.  All posts will rely on the GCC compiler.</p>

<p><strong><img src="../images/GCCLogo.png" alt="" />Setting Up the GCC Compiler</strong></p>

<p>I setup a C environment as basic I could.  There may be easier ways to go about this, but I wanted to use GCC to compile.</p>

<p>To setup the environment:</p>

<p>1. I downloaded and setup <a href="http://www.mingw.org/wiki/HOWTO_Install_the_MinGW_GCC_Compiler_Suite">MinGW32</a>.</p>

<p>2. I added these <strong>includes</strong> to make the code go.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;windows.h&gt;
#include &lt;windef.h&gt;
#include &lt;winnt.h&gt;
#include &lt;winbase.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/time.h&gt;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>I used this line to build it:</p>

<p><strong>$ gcc -o main main.c</strong></p>

<p>As for editing, I‚Äôve really grown to love <a href="http://www.sublimetext.com/2">Sublime Text 2</a>.</p>

<p>If you have issues<strong>, make sure directory containing your files is in your PATH environment variable</strong> (I go over how to add the directory to your environment variables in this <a href="http://letsmakerobots.com/content/lpc1114-setup-bare-metal-arm">post</a>).</p>

<p><strong>Intel Hexfile to An Array Based on Data Address</strong></p>

<p>To load data from an <a href="http://en.wikipedia.org/wiki/Intel_HEX">Intel HEX format file</a> I used several functions, open_file() to create a data stream, more commonly know as a <a href="http://www.gnu.org/software/libc/manual/html_node/Streams.html#Streams">file pointer</a>, from the file I wanted to read.  And hex_file_to_array(), to parse the hex file and extract the data.</p>

<p><img src="../images/hexfile2.png" alt="" /></p>

<p><strong>main.c</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="n">MAIN</span><span class="p">.</span><span class="n">C</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="c1">//If the user fails to give us two arguments yell at him.</span>
	<span class="k">if</span> <span class="p">(</span> <span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">fprintf</span> <span class="p">(</span> <span class="n">stderr</span><span class="p">,</span> <span class="s">"Usage: %s &lt;readfile1&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">);</span>
		<span class="n">exit</span> <span class="p">(</span> <span class="n">EXIT_FAILURE</span> <span class="p">);</span>
	<span class="p">}</span>
	<span class="c1">// Data array</span>
	<span class="kt">uint8_t</span> <span class="n">HEX_array</span><span class="p">[</span><span class="mi">32768</span><span class="p">];</span>

	<span class="c1">// Bytes read into array.</span>
	<span class="kt">int</span> <span class="n">HEX_array_size</span><span class="p">;</span>

	<span class="c1">//File to be loaded.</span>
	<span class="kt">FILE</span> <span class="o">*</span><span class="n">hex_file</span><span class="p">;</span>

	<span class="c1">//Open file using command-line info; for reading.</span>
	<span class="n">hex_file</span> <span class="o">=</span> <span class="n">open_file</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">"rb"</span> <span class="p">);</span>

	<span class="c1">// Load the data from file</span>
	<span class="n">HEX_array_size</span> <span class="o">=</span> <span class="n">hex_file_to_array</span><span class="p">(</span><span class="n">hex_file</span><span class="p">,</span> <span class="n">HEX_array</span><span class="p">);</span>


<span class="p">}</span> <span class="c1">// END PROGRAM</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>6:  Let‚Äôs check the number of arguments passed in by the user.  If there is no file name, then we exit.</li>
  <li>11: Declare a unsigned array for the data.  I‚Äôve set it arbitrarily, but it will need to be large enough for the amount of data to be extracted from the hexfile.</li>
  <li>17: Here we create a pointer to a file data stream.</li>
  <li>20: We pass the pointer to the data stream to the <strong>open_file</strong> function.  We are setting up to only read the file in binary.  We pass it the file we wish to open and it returns the opened file.</li>
  <li>23: We pass <strong>hex_file_to_array</strong> a file pointer and pointer to an an array.  This function reads the hex file, parses it, extracting the data and placing them into the the uint8_t array based on the data‚Äôs address found in the hexfile.  The function then returns the number of data bytes found in the hex file.</li>
</ul>

<p><strong>open_file()</strong></p>

<p>This function takes the name of a file and the <a href="http://www.c4learn.com/c-programming/c-file-open-modes/">mode</a> under which to open it, then attempts to open a file pointer to this file.  If it is is successful, it returns the pointer to the now open file.  If it it fails, the program exits with an error code.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="n">MAIN</span><span class="p">.</span><span class="n">C</span>

<span class="c1">//Open file for reading, function.</span>
<span class="kt">FILE</span> <span class="o">*</span><span class="nf">open_file</span> <span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">mode</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">fileOpen</span> <span class="o">=</span> <span class="n">fopen</span> <span class="p">(</span> <span class="n">file</span><span class="p">,</span> <span class="n">mode</span> <span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">fileOpen</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">perror</span> <span class="p">(</span> <span class="s">"Unable to open file"</span> <span class="p">);</span>
    <span class="n">exit</span> <span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">fileOpen</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>To understand this function it pays to understand well the Intel HEX file format.</p>

<p><strong>Parsed HEX file:</strong></p>

<p>Let's take a look at the raw data,</p>
<pre>:10010000214601360121470136007EFE09D2190140
:100110002146017E17C20001FF5F16002148011928
:10012000194E79234623965778239EDA3F01B2CAA7
:100130003F0156702B5E712B722B732146013421C7
:00000001FF</pre>

<p><strong>Parsed HEX file:</strong></p>
<pre>: 11 2222 33 44444444444444444444444444444444 55 \n</pre>
<ol>
<li>'<strong>:</strong>' = Start Code.
</li><li>11 = Byte Count
</li><li>2222 = Address
</li><li>33 = Data Type
</li><li>44 = <strong>Data</strong>
</li><li>55 = Check Sum
</li><li>'\n' = End Code</li></ol>
<p>All of the information in the file is important, but we are only looking to put the <strong>Data</strong> into the array. To extract this data we are going to use three sub-routines: </p>
<ol>
<li>read_byte_from_file()
</li><li>Ascii2Hex()
</li><li>clear_special_char()</li></ol>

<p><strong>read_byte_from_file()</strong></p>

<p>One bit to understand about hex files is the data is actually stored as ASCII characters.  When we open a file pointer to these ASCII characters, we can‚Äôt just read the bytes, since they‚Äôd simply be an ASCII character representing the <a href="http://en.wikipedia.org/wiki/Nibble">nibble</a> read.  To make the conversion we get a character, store it as a binary nibble A, get another character and store it as binary nibble B.  We then combine nibble A and B into a single byte.</p>

<p>The function takes three parameters: the file pointer, a uint8_t pointer for storing the complete byte, and the total_chars_read, which allows us to track how far we are into the file.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="n">DATA</span><span class="p">.</span><span class="n">C</span>

<span class="kt">uint8_t</span> <span class="nf">read_byte_from_file</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">char_to_put</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">total_chars_read</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//Holds combined nibbles.</span>
	<span class="kt">uint8_t</span> <span class="n">hexValue</span><span class="p">;</span>
	<span class="c1">//Get first nibble.</span>
	<span class="o">*</span><span class="n">char_to_put</span> <span class="o">=</span> <span class="n">fgetc</span> <span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="n">clear_special_char</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">char_to_put</span><span class="p">,</span> <span class="n">total_chars_read</span><span class="p">);</span>
	<span class="c1">//Put first nibble in.</span>
	<span class="n">hexValue</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ascii2Hex</span><span class="p">(</span><span class="o">*</span><span class="n">char_to_put</span><span class="p">));</span>
	<span class="c1">//Slide the nibble.</span>
	<span class="n">hexValue</span> <span class="o">=</span> <span class="p">((</span><span class="n">hexValue</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">);</span>
	<span class="c1">//Put second nibble in.</span>
	<span class="o">*</span><span class="n">char_to_put</span> <span class="o">=</span> <span class="n">fgetc</span> <span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="n">clear_special_char</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">char_to_put</span><span class="p">,</span> <span class="n">total_chars_read</span><span class="p">);</span>
	<span class="c1">//Put the nibbles together.</span>
	<span class="n">hexValue</span> <span class="o">|=</span> <span class="p">(</span><span class="n">Ascii2Hex</span><span class="p">(</span><span class="o">*</span><span class="n">char_to_put</span><span class="p">));</span>
	<span class="c1">//Return the byte.</span>
	<span class="o">*</span><span class="n">total_chars_read</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hexValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>6: Declaring a 8-bit unsinged integer to hold the finished byte.</li>
  <li>8: Get an ASCII character from the file pointer.</li>
  <li>9: Here we call the cleaer_special_char function to remove ‚Äò\n‚Äô and ‚Äò\r‚Äô found in the hex file.</li>
  <li>11: We then convert the ASCII character into a true binary nibble.  The result is stored in the string.  (I will cover the Ascii2Hex function below.)</li>
  <li>The above steps are repeated for nibble B.</li>
  <li>18: We combine the string of nibbles into a byte.</li>
  <li>26: We increment two ASCII characters read from the file pointer.</li>
</ul>

<p><strong>clear_special_char()</strong></p>

<p>The clear special character function is simply meant to remove the ‚Äò:‚Äô, ‚Äò\n‚Äô, and ‚Äò\r‚Äô characters from the data stream.  It simply looks through the character pulled from the data stream.  If it is not a special character, it does nothing.  If it is, it increments the character counter and discards the character.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="n">DATA</span><span class="p">.</span><span class="n">C</span>

<span class="kt">void</span> <span class="nf">clear_special_char</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">charToPut</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">totalCharsRead</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//Removes CR, LF, ':'  --Bdk6's</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">charToPut</span> <span class="o">==</span> <span class="sc">'\n'</span> <span class="o">||</span> <span class="o">*</span><span class="n">charToPut</span> <span class="o">==</span> <span class="sc">'\r'</span> <span class="o">||</span> <span class="o">*</span><span class="n">charToPut</span> <span class="o">==</span><span class="sc">':'</span><span class="p">){</span>
		<span class="p">(</span><span class="o">*</span><span class="n">charToPut</span> <span class="o">=</span> <span class="n">fgetc</span> <span class="p">(</span><span class="n">file</span><span class="p">));</span>
		<span class="o">*</span><span class="n">totalCharsRead</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><strong>Ascii2Hex()</strong></p>

<p>Another fairly simple function.  Here, we simply find the numeric value of the ASCII character and convert it to its binary equivalent.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="n">DATA</span><span class="p">.</span><span class="n">C</span>

<span class="c1">//Copied in from lpc21isp.c</span>
<span class="kt">uint8_t</span> <span class="nf">Ascii2Hex</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'F'</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'A'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'f'</span><span class="p">)</span>
	<span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// this "return" will never be reached, but some compilers give a warning if it is not present</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This function is pretty simple, if you keep in mind each character is actually an integer.  For example, the if-statements could be re-written as follows,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">)</span>
   <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">65</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">70</span><span class="p">)</span>
   <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">65</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">97</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">102</span><span class="p">)</span>
   <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">c</span> <span class="o">-</span> <span class="mi">97</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>You can use an <a href="http://www.bibase.com../images/ascii.gif">ASCII reference table</a> to determine how a character read will be interpreted.  For instance, ‚ÄòD‚Äô or ‚Äòd‚Äô would be 68 or 100.  68 - 65 + 10 = 13.  We know D is hexadecimal for 13 (0 = 0, 1 = 1, 1 = 2, etc‚Ä¶ A = 10, B, = 11, C = 12, <strong>D = 13</strong>, E = 14, F = 15).</p>

<p>This brings us to the main function,</p>

<p><strong>read_line_from_hex_file()</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="n">DATA</span><span class="p">.</span><span class="n">C</span>

<span class="n">bool</span> <span class="nf">read_line_from_hex_file</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">line_of_data</span><span class="p">[],</span> <span class="kt">long</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">combined_address</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">bytes_this_line</span><span class="p">)</span>
<span class="p">{</span>
		<span class="kt">int</span> <span class="n">data_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">char_to_put</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">total_chars_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="c1">//To hold file hex values.</span>
		<span class="kt">uint8_t</span> <span class="n">byte_count</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">datum_address1</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">datum_address2</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">datum_record_type</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">datum_check_sum</span><span class="p">;</span>

		<span class="c1">//BYTE COUNT</span>
		<span class="n">byte_count</span> <span class="o">=</span> <span class="n">read_byte_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">char_to_put</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total_chars_read</span><span class="p">);</span>

		<span class="c1">// No need to read, if no data.</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">byte_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span><span class="k">return</span> <span class="nb">false</span><span class="p">;}</span>

		<span class="c1">//ADDRESS1 //Will create an 8 bit shift. --Bdk6's</span>
		<span class="n">datum_address1</span> <span class="o">=</span> <span class="n">read_byte_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">char_to_put</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total_chars_read</span><span class="p">);</span>

		<span class="c1">//ADDRESS2</span>
		<span class="n">datum_address2</span> <span class="o">=</span> <span class="n">read_byte_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">char_to_put</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total_chars_read</span><span class="p">);</span>

		<span class="c1">//RECORD TYPE</span>
		<span class="n">datum_record_type</span> <span class="o">=</span> <span class="n">read_byte_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">char_to_put</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total_chars_read</span><span class="p">);</span>

		<span class="c1">// No need to read, if not data.</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">datum_record_type</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span><span class="k">return</span> <span class="nb">false</span><span class="p">;}</span>

		<span class="o">*</span><span class="n">combined_address</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">datum_address1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">datum_address2</span><span class="p">;</span>

		<span class="c1">// DATA</span>
		<span class="k">while</span><span class="p">(</span><span class="n">data_index</span> <span class="o">&lt;</span> <span class="n">byte_count</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">line_of_data</span><span class="p">[</span><span class="n">data_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_byte_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">char_to_put</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total_chars_read</span><span class="p">);</span>
			<span class="n">data_index</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">bytes_this_line</span> <span class="o">=</span> <span class="n">data_index</span><span class="p">;</span>

		<span class="c1">// CHECKSUM</span>
		<span class="n">datum_check_sum</span> <span class="o">=</span> <span class="n">read_byte_from_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">char_to_put</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total_chars_read</span><span class="p">);</span>

		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The above code parses exactly one line of hex data from the file pointer.</p>

<ul>
  <li>17: We read the first byte of a line.  This should be the ‚Äò:‚Äô character, but remember our clear_special_char() should skip this and read the next two bytes ‚Äò1‚Äô and ‚Äò0‚Äô (green).  The ‚Äú10‚Äù is how many bytes of data (blue) found on this line.  Note, 10 is not a decimal number, it‚Äôs hexadecimal.  Meaning, there should be 16 bytes of data found on this line.</li>
  <li>20: We check if there was any data on this line.  If there are zero data, we return false.</li>
  <li>23: Take the first byte of the data address (purple).</li>
  <li>26: Take the second byte of the data address (purple).</li>
  <li>29: Get the byte (red) identifying the type of information found on this line.  We are only looking for data (‚Äò00‚Äô).  The other types are explained well at the ole‚Äô Wiki article: <a href="http://en.wikipedia.org/wiki/Intel_HEX#Record_types">Intel HEX record types</a>.</li>
  <li>32: If the record type is not data, we don‚Äôt want it.  We return false.</li>
  <li>34: Combine the two 8-bit address bytes into one 16-bit address.</li>
  <li>37: Let‚Äôs get all the data found on this line and put it into the array we provided the function.</li>
  <li>42: We have to keep track of how many bytes are on each line, to complete our address of the data.  Therefore, we pass it back to hex_file_to_array().</li>
  <li>45: I read the checksum, but I don‚Äôt do anything with it.  I probably should.</li>
</ul>

<p><strong>hex_file_line_count()</strong></p>

<p>To properly parse the hexfile we need to know how many lines are found in the the file.  We can find this information several ways, but I counted the number of line start characters ‚Äò:‚Äô.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="n">MAIN</span><span class="p">.</span><span class="n">C</span>

<span class="kt">int</span> <span class="nf">hex_file_line_count</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span> <span class="n">file_to_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">line_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">got_char</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">got_char</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">got_char</span> <span class="o">=</span> <span class="n">fgetc</span><span class="p">(</span><span class="n">file_to_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">got_char</span> <span class="o">==</span> <span class="sc">':'</span><span class="p">){</span><span class="n">line_count</span><span class="o">++</span><span class="p">;}</span>
	<span class="p">}</span>
	<span class="n">rewind</span><span class="p">(</span><span class="n">file_to_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">line_count</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>8: Loops until the end-of-file character is reached.</li>
  <li>10: Gets a ASCII character from the file pointer.</li>
  <li>11: We check to see if the character we go was line start character ‚Äò:‚Äô.</li>
  <li>13: This function iterates through the entire file, but we want to start pulling data from the beginning of the file, so we <a href="http://www.tutorialspoint.com/c_standard_library/c_function_rewind.htm">rewind</a> the file to the first character.</li>
  <li>14: We return the number of lines.</li>
</ul>

<p><strong>hex_file_to_array()</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="code"><pre><span class="n">DATA</span><span class="p">.</span><span class="n">C</span>

<span class="kt">int</span> <span class="nf">hex_file_to_array</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">hex_data</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="c1">// 1. Get line count.</span>
	<span class="c1">// 2. Read a line. From ':' to '\n'</span>
	<span class="c1">// 3. Parse a line.</span>
	<span class="c1">//   Repeat for all lines.</span>

	<span class="c1">// Data per line.</span>
	<span class="kt">uint8_t</span> <span class="n">line_of_data</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">long</span> <span class="kt">int</span> <span class="n">combined_address</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>

	<span class="c1">// Indices and counters</span>
	<span class="kt">int</span> <span class="n">hex_line_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chars_this_line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total_chars_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// How many lines in the hexfile?</span>
	<span class="kt">int</span> <span class="n">hex_lines_in_file</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes_this_line</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>

	<span class="c1">// Let's count how many lines are in this file.</span>
	<span class="n">hex_lines_in_file</span> <span class="o">=</span> <span class="n">hex_file_line_count</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="c1">// Indices for parsing.</span>
	<span class="kt">int</span> <span class="n">line_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">byte_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">read_line_ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="c1">// Parse all lines in file.</span>
	<span class="k">while</span><span class="p">(</span><span class="n">line_index</span> <span class="o">&lt;</span> <span class="n">hex_lines_in_file</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">read_line_ok</span> <span class="o">=</span> <span class="n">read_line_from_hex_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">line_of_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">combined_address</span><span class="p">[</span><span class="n">line_index</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">bytes_this_line</span><span class="p">[</span><span class="n">line_index</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">read_line_ok</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"Line#: %i. Dude, that's not data!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">line_index</span><span class="p">);</span>
			<span class="n">read_line_ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">while</span><span class="p">(</span><span class="n">byte_index</span> <span class="o">&lt;</span> <span class="n">bytes_this_line</span><span class="p">[</span><span class="n">line_index</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="n">hex_data</span><span class="p">[</span><span class="n">combined_address</span><span class="p">[</span><span class="n">line_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">byte_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_of_data</span><span class="p">[</span><span class="n">byte_index</span><span class="p">];</span>
			<span class="n">line_of_data</span><span class="p">[</span><span class="n">byte_index</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
			<span class="n">byte_index</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">byte_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">line_index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// Print out parsed data.</span>
	<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">printed_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">hex_lines_in_file</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">bytes_this_line</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"%02X "</span><span class="p">,</span> <span class="n">hex_data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="p">(</span><span class="n">printed_bytes</span><span class="p">)]);</span>
			<span class="n">j</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printed_bytes</span> <span class="o">+=</span> <span class="n">bytes_this_line</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
		<span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">k</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">total_chars_read</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// End hex_file_to_array</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>23: We count the number of lines in the file we wish to extract data.</li>
  <li>31: This is the work-horse loop.  We loop until the we have read through all the lines we counted.</li>
  <li>33: We pass read_line_from_hex() our variables we wish to fill.  The hex file we want to parse (file), the buffer we hold the line data in, the int array which will serve to hold the address of this line of data, a variable to hold the number of bytes in this line.  If the function was got data, it will return true.  Otherwise, it will return false.  We store this flag to make sure we got something.</li>
  <li>34: We check to see if we actually got data from our attempt.</li>
  <li>39: Here, we move the line of data from the buffer into the final array.</li>
  <li>41: We place the data into the array based upon the address we pulled from the line (address1 + address2) and the byte number.</li>
  <li>42: Reset the buffer to nil.</li>
  <li>49-64:  Finally, we print out the data.  The k-loop goes through each line we extracted; the j-loop goes through each byte found on the respective line.</li>
</ul>

<p>And that‚Äôs it.  <strong>Note, 49-64 is meant to demonstrate the data is properly extracted.  These lines could be moved to another function where the data may be used as needed.</strong></p>

<p><img src="../images/Hex_file_data_dump1.png" alt="" /></p>
:ET