I"dH<p>Mixing R and SQL is powerful.  One of the easiest ways to implement this combination is with the R library SQLdf.</p>

<p>If TL;DR, skip to <code class="highlighter-rouge">Coerce Date Types into Strings before Passing to SQLdf</code> at bottom.</p>

<h2 id="sqldf">SQLdf</h2>
<p>The power of SQLdf comes from its ability to convert dataframes into SQLite databases on the fly.  To the user, it doesn’t appear like anything special is going on, but under the hood R is working together with a SQLite client to create a table which can be queried and manipulated with ANSI SQL calls.</p>

<p>For example,</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">dataFrame1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.csv</span><span class="p">(</span><span class="n">pathToData</span><span class="p">)</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="s2">"sqldf"</span><span class="p">)</span><span class="w">
</span><span class="n">dataFrame2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT FirstName FROM dataFrame"</span><span class="p">)</span></code></pre></figure>

<p>These three lines do a lot.  It loads data from a CSV, loads a library of functions for convert R dataframes into SQLite databases, and then the <code class="highlighter-rouge">sqldf()</code> function call does two things at once.  It converts the R dataframe into a SQLite database and then queries it for the FirstName column.</p>

<p>If we were to assume the dataFrame1 variable contained data like this:</p>

<table>
  <thead>
    <tr>
      <th>PersonalID</th>
      <th>FirstName</th>
      <th>LastName</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>B7YIOJIGF9CDP6FV7TANQXLMQRMBTVTB</td>
      <td>Bob</td>
      <td>Person</td>
    </tr>
    <tr>
      <td>ASGJ4F95HS85N39DJ12AJB094M59DJ45</td>
      <td>Jane</td>
      <td>People</td>
    </tr>
  </tbody>
</table>

<p>Then the <code class="highlighter-rouge">dataFrame2 &lt;- sqldf("SELECT FirstName FROM dataFrame)</code> will create a variable called <code class="highlighter-rouge">dataFrame2</code> which contains the FirstName column from dataFrame1</p>

<table>
  <thead>
    <tr>
      <th>FirstName</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Bob</td>
    </tr>
    <tr>
      <td>Jane</td>
    </tr>
  </tbody>
</table>

<p>And this is how we will shape our data in the R-SQL way.</p>

<h2 id="datatypes">Datatypes</h2>
<p>One of the most important things a human can learn about computers is something called datatypes.  When computers process information they need a little help from humans in attempt to understand what to do with the information.  For example, what do these numbers mean to you?</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">76110, 444-325-7645, 10/24/1980</code></pre></figure>

<p>Most humans (at least in the United States) will know the first number is a ZIP code, the second a phone number, and last date.  Humans know this because our brains have learned how to discern from context.  In the case of the ZIP code, it’s exactly 5 numbers, the phone contains dashes at at exact places, and the date contains slashes in the exact spot we’d expect of a date.</p>

<p>Unfortunately, computers have a little more difficulty with this.  Most computers are smart enough now days to know the phone number and date of birth, but the ZIP code will confuse the heck out of a computer.</p>

<p>A computer’s initial reaction in seeing the ZIP code is, “Oh, you mean 76,110.  That’s a big number.”  When really, this number represents a geographic location.</p>

<p>Ok, let’s make this more relevant to HMIS work.  The way to help a computer understand what numbers are representing is by telling the computer what type of data a particular column is.  This is known as a datatype.  For us, we really only deal with a few datatypes, but their are hundreds of thousand of datatypes.</p>

<p>In R you can see what datatype a column of your dataframe is by clicking the blue button next to the dataframe name in the Global Environment variables.</p>

<p><img src="../images/r-datatypes.png" alt="" /></p>

<p>We will be dealing with the following:</p>

<ul>
  <li>Dates (called “POSXct” in R)</li>
  <li>Strings (called “chr” in R)</li>
  <li>Numbers</li>
  <li>Factors</li>
</ul>

<p>Of course, every programming language can calls these datatypes by different names, thus, furthering confusion.  (I mean, c’mon, programming is simple enough as it is–we’ve got to make it <em>a little</em> challenging.)</p>

<h3 id="dates">Dates</h3>
<p>Date datatypes usually look like this:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="m">10</span><span class="o">/</span><span class="m">24</span><span class="o">/</span><span class="m">1980</span></code></pre></figure>

<p>But it can come in many different formats.  It’s probably best to differentiate between <em>datatype</em> and <em>data format</em>.  A data type describes how the information should be used–it’s important for a computer.  Data format describes how a computer should display information to the human–therefore, it’s useful for a human.</p>

<p>An example of different formats of the same data:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="m">10</span><span class="o">/</span><span class="m">24</span><span class="o">/</span><span class="m">1980</span><span class="w">
</span><span class="m">1980-10-24</span><span class="w">
</span><span class="m">102480</span></code></pre></figure>

<p>Ok, back to the date datatype.  It is used when dealing with dates.  By declaring a variable as having a date datatype, it is telling the computer whatever we put into that variable to interpret as a date.  Simple enough.</p>

<h3 id="strings">Strings</h3>
<p>When we talk about string we aren’t talking about fuzzy things kittens chase.  A string datatype is a series of characters (one part of a string) strung together.  <em>Anything</em> can be a string.  They are probably the most important datatype, since they can tell a computer to look at a number and see something else.  Confused?  Let’s look at some examples.</p>

<p>We tell a computer data is a string is by putting it in double quotes <code class="highlighter-rouge">"this is a string"</code> or single quotes <code class="highlighter-rouge">'this is also a string'</code>.</p>

<p>Here’s an example of assigning a string in R:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">myFirstString</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"this is a string"</span></code></pre></figure>

<p>Great! But what can we do with it?  Well, a lot.</p>

<p>Let’s say we wanted to pass a path of a file to a <code class="highlighter-rouge">read.csv()</code> function.  We could do so by providing the path as a string.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">dataFrame</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"/Users/user/Downloads/Client.csv"</span><span class="p">)</span></code></pre></figure>

<p>The above will load the Client.csv file located at the <code class="highlighter-rouge">/Users/user/Downloads/</code> directory–the computer knows how to read the path because it’s a string.</p>

<p>But why are strings so important?  Well, they allow us to tell a computer to override its basic instinct and view a piece of data as something other than what the computer would guess it is.</p>

<p>Returning to the ZIP code.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">notAZipCode</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">76110</span><span class="w">
</span><span class="n">myZipCode</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"76110"</span></code></pre></figure>

<p>These variable assignments may seem to be exactly the same, however, the first one creates a variable as a number, but the second tells the computer, “This is a not a number, it is something else–please don’t pretend to understand it.  I’ll tell you exactly what to do with it later.”</p>

<h3 id="numbers">Numbers</h3>
<p>Number datatypes are easy.  It’s pretty much how a computer tries to look at all data you provide it.  One important characteristic about numbers, you can have the computer perform math functions on numbers, which you couldn’t on strings.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">dataframe1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="m">12</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">12</span><span class="w"> 
</span><span class="n">datafram2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="s2">"12"</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="s2">"12"</span></code></pre></figure>

<p>Above, <code class="highlighter-rouge">dataframe1</code> will contain 144 after being executed.  But if the second line is attempted to be executed the computer will freak out, “This is a string! I can’t add strings! You told me you’d tell me what to do with them…”</p>

<h3 id="factors">Factors</h3>
<p>Factors are a special datatype in R.  Most of all the variables we load in R will start out as factors.  Essentially, factors are categories of data.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">Red</span><span class="p">,</span><span class="w">
</span><span class="n">Orange</span><span class="p">,</span><span class="w">
</span><span class="n">Green</span><span class="p">,</span><span class="w">
</span><span class="n">Blue</span><span class="p">,</span><span class="w">
</span><span class="n">Indigo</span><span class="p">,</span><span class="w">
</span><span class="n">Violet</span></code></pre></figure>

<p>Is an example of factors.  They are categories of data.  The important of factors will become more evident as we work through these tutorials in R.</p>

<p><em>If you don’t understand factors, it’s cool.  Just think of them as strings.</em> However, if you don’t understand strings, please ask any questions in comments below.  Understanding them is critical to working with SQLdf.</p>

<h2 id="sqldf-and-datatypes">SQLdf and Datatypes</h2>
<p>Anytime you mix two different languages it pays to be careful about meaning.  As I learned once by talking about <em>pie</em> as something I liked–come to find out, it was funny to Hispanic friends who were learning English.  (Apparently pie is Spanish for foot?)</p>

<p>When mixing R and SQL we must be careful about how the two languages look at the datatypes.  In R it sees dates as a <code class="highlighter-rouge">POSXct</code> datatype (this is essentially fancy <code class="highlighter-rouge">date</code> datatype.  <a href="http://biostat.mc.vanderbilt.edu/wiki/pub/Main/ColeBeck/datestimes.pdf">Would you like to know more</a>?)</p>

<p>Well, this is all fine and dandy, but when we pass commands from R to SQL it is all passed as a string.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">dataFrame2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT * FROM dataFrame1"</span><span class="p">)</span></code></pre></figure>

<p>Notice <code class="highlighter-rouge">SELECT * FROM dataFrame1</code> is all in quotation marks? This turns it into a string then it passes it SQLite, which is hidden to us.</p>

<p>If all this is a bit overwhelming, no worries.  Bookmark this page to refer back to later.  Just remember the following:</p>

<p>Date columns must be converted into a <code class="highlighter-rouge">chr</code> datatype <em>before</em> passing it to SQL.  How to we convert datatypes?  It’s pretty darn simple.  We use something called data coercion.</p>

<h2 id="coercing-data-types">Coercing Data Types</h2>
<p>Let’s go back to that ZIP code and number example.  Let’s say the computer reads all your ZIP codes from a file as a number.  This happens a lot, since to the computer that’s what it looks like–so it guesses that’s what you are going to want.</p>

<p>But no, we want those ZIP codes to be strings. To do this, we can get a particular column from a dataframe by writing the name of the dataframe then <code class="highlighter-rouge">$</code> then the name of the column.  For example, <code class="highlighter-rouge">datafram$zipCodes</code> will return only the column <code class="highlighter-rouge">zipCodes</code> from dataframe.</p>

<p>Alright, now we have a way to select one column from our dataframe we can attempt to convert that one column’s datatype.  To do this use the <code class="highlighter-rouge">as.character()</code> command.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">dataframe</span><span class="o">$</span><span class="n">zipCodes</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as.character</span><span class="p">(</span><span class="n">dataFrame</span><span class="o">$</span><span class="n">zipCodes</span><span class="p">)</span></code></pre></figure>

<p><img src="../images/zip-codes-number-to-string.png" alt="" /></p>

<p>This will convert the zipCode column from a number into a string, then, it assigns it back to the column zipCodes.  Boom! We’ve told the computer to stop trying to make a ZIP code a number.  Instead, treat it as a string.  And with that, we will tell the computer later how to use ZIP codes.</p>

<h2 id="coerce-date-types-into-strings-before-passing-to-sqldf">Coerce Date Types into Strings before Passing to SQLdf</h2>
<p>Ok, now for the reason for this entire article.  Before passing any dates to SQLdf we need to first convert them to strings.  Otherwise, SQLdf will try to treat them as numbers–which will cause a lot of heartache.</p>

<p>For example, a Client.csv file should have a <code class="highlighter-rouge">DateCreated</code> column.  This represents the date a case-manager put the data into HMIS.  The data should look something like this:</p>

<table>
  <thead>
    <tr>
      <th>…</th>
      <th>DateCreated</th>
      <th>DateUpdated</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>…</td>
      <td>10/23/14 0:01</td>
      <td>4/23/15 15:27</td>
    </tr>
    <tr>
      <td>…</td>
      <td>5/22/13 9:23</td>
      <td>10/15/16 1:29</td>
    </tr>
    <tr>
      <td>…</td>
      <td>6/3/15 19:22</td>
      <td>3/17/17 21:09</td>
    </tr>
  </tbody>
</table>

<p>Let’s try to get all of the clients who’ve been entered after 10/01/2014.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">dataFramContainingDates</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"/Users/user/Downloads/Client.csv"</span><span class="p">)</span><span class="w">
</span><span class="n">datesEntered</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT * FROM dataFramContainingDates WHERE DateCreated &gt; '2014-10-01'"</span><span class="p">)</span></code></pre></figure>

<p>The above code should provide every column where DateCreated date is greater than 2014-10-01.  But, instead, it will result in an empty dataframe.  Waaah-waah.</p>

<p>Essentially, this is because SQL is comparing a number and a string.  It freaks the computer out.</p>

<p>Instead, we should convert the <code class="highlighter-rouge">DateCreated</code> column to a string instead of a date.  Then, SQL will actually convert it from a string to a date.</p>

<p>Confused?  Imagine me when I was trying to figure this out on my own.</p>

<p>Ok, so, the take away?  Before passing any dates to SQL convert them to strings.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">dataFramContainingDates</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read.csv</span><span class="p">(</span><span class="s2">"/Users/user/Downloads/Client.csv"</span><span class="p">)</span><span class="w">
</span><span class="n">dataFrameContaingDates</span><span class="o">$</span><span class="n">DateCreated</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nf">as.character</span><span class="p">(</span><span class="n">dataFrameContaingDates</span><span class="o">$</span><span class="n">DateCreated</span><span class="p">)</span><span class="w">
</span><span class="n">datesEntered</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT * FROM dataFramContainingDates WHERE DateCreated &gt; '2014-10-01'"</span><span class="p">)</span></code></pre></figure>

<p>By using the <code class="highlighter-rouge">as.character</code> function to convert the <code class="highlighter-rouge">DateCreated</code> column to a string and then assigning it back to the dateframe, it sets SQL up to do the date comparisons correctly.  Using the dateframe from above, this should result in the following table:</p>

<table>
  <thead>
    <tr>
      <th>…</th>
      <th>DateCreated</th>
      <th>DateUpdated</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>…</td>
      <td>10/23/14 0:01</td>
      <td>4/23/15 15:27</td>
    </tr>
    <tr>
      <td>…</td>
      <td>6/3/15 19:22</td>
      <td>3/17/17 21:09</td>
    </tr>
  </tbody>
</table>

<p>Confused as heck? Feel free to ask questions in the comments below!</p>
:ET