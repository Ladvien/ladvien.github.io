---
layout: article
title: HM-1X Aid
categories: robots
excerpt:
tags: [robots]
color: "#152a55"
image:
  feature: HM-10-2.jpg
  teaser: HM-10-2.jpg
  thumb:
comments: true
---

###Overview

Well, I've had the urge to hack.  It's been strong for awhile now, sadly, with a more than fullt-time job and Bek in graduate school, I've just had no time.  **Until now!**  The new job I have (HMIS Database Manager) has _actual_ vacation time.  I've had almost two weeks off (combined with the Christmas holiday).  The first few days were obviously spent working...**But!** After turning my phone and email (the work email) I was able to...catch up on family time.  Sigh.  Then, clean house.  Then, get bored.  But with a few days left I actually got some hacking in.

I downloaded Visual Studio Express on my work computer a few months ago.  (Shh.  Don't tell the boss.) But I've not had time to write a single line of code.  This holiday was a good time to learn C\#!

Two weeks later I had this monster,

<div class="flex-video">
<iframe width="420" height="315" src="https://www.youtube.com/embed/XtrS7ENc1EU" frameborder="0" allowfullscreen></iframe>
</div>

It is meant to be a GUI for the HM-10, HM-11, and HM-15 modules.  The highlights,

[HM-1X Aid Download](https://github.com/Ladvien/HM-1X-Build/raw/master/setup.exe)

The source can be found,

[HM-1X Aid Source](https://github.com/Ladvien/HM-1X_Aid_v01)

1. It uses threads to prevent any "Sleeping."  Keeps the UI healthy.
2. IO.SerialPorts _should_ allow a lot of USB-to-UART chips to work.
3. Basic Terminal App features (view as ASCII, HEC, Decimal, etc.) like RealTerm and the others. BUT! With one feature I've longed for in a terminal app for so damn long.  The ability to save your settings on exit.  No more selecting 9600 baud for the billionth time.
4. I've put a lot of command validity checks in the system.  For example, if you were to type "AT+CON0123**S**6789012" Would not be a valid command normally, but terminal will convert the "S" to "F."
5. I have also imbued it with a bit my understanding of the HM-1X datasheets.  This is probably the greatest selling point of the program, sadly.
6. **C# is my new favorite.  Don't judge me :P.**

I thought I would take some time to go into the code involved in the little terminal, not for posterity, merely for my own reference.

**"Attention .NET Users! This is the law. Disperse immediately, or we will use lethal force to clear the area. You have been warned. You now have 20 seconds to comply..."**


![](http://www.geek.com/wp-content/uploads/2015/09/stallone-judge-dredd-590x332.jpg)


### Object Oriented Programming

I have post as much lately.  I think it is a combination of losing LMR and not having time since Bek started school.  But I have definitely been writing code.  The focus has been on learning OOP design.  This this C\# program was probably my first _real_ object-oriented program.  But I have also been writing in [Swift](https://developer.apple.com/ios/?cid=wwa-us-kwg-features) for iOS, which is an OOP language as well.

Arlight, so what's the difference between OOP and the other thing? And why learn OOP, I thought robot used microcontollers whichi are much too small to handle OOP?

Well, as I've learned, every robot builder is _already_ an object oriented programmer.

#### Difference between OOP and Procedural programming

I will not attempt to explain more poorly what I've learned, rather, I'm going to list what has helped me get a better understanding.

1. [Object-Oriented programming](https://www.youtube.com/watch?v=lbXsrHGhBAU) (video)
2. [Procedural Programming](https://www.youtube.com/watch?v=b4n9KYD05jg) (video)
3. [Derek Banas' Design Patterns Series](https://www.youtube.com/watch?v=vNHpsC5ng_E&list=PLF206E906175C7E07) (examples in Java, but it helped me the most.  Got to see OOP in action.)

I believe every roboticist is both an object oriented programmer and a procedural programmer.  They create objects with specific functions (PCBs, STLs, etc.), retaining the plans to make copies of such objects in the future.  They instantiate those objects (print the STL, send the PCB file to OSHPark, etc).  Each of these objects created usually has a specific purpose.  The design of the object, for instance a motor-controller, is often only accessible by a specific input such as UART connection.  And its outputs are controlled by how the inputs are digested by the motor-controller itself. The robot-builder may decide to add an accelerometer to the motor-controller by copying the design files and adding the needed accelerometer circuit (inheritance).  It seems like all the concepts are there,

1. [Abstraction](https://en.wikipedia.org/wiki/Abstraction_%28computer_science%29)
2. [Encapsulation](https://en.wikipedia.org/wiki/Encapsulation_%28computer_programming%29)
3. [Polymorhphism](https://en.wikipedia.org/wiki/Polymorphic_code)
4. [Inheritance](https://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29)

However, each roboticist must line the insides of objects with procedures that move data through in a predictable manner.  This means, at some granularity point, objects are filled with small runs of procedural programming (I realize Procedural Programming and programming procedurally are not the same, but hey, it's my article and I'm trying to make a point).

Moving away from the hippy-dippy stuff; for my personal development as a robot builder I will be taking time to learn both, since both seem roots of computational-thinking.

In application, I want to know procedural programming since microcontrollers often have small memory sets and the code needs to move from input to output with little overhead (Hmm, procedural programming is a linear style and a line is the shortest distance between two points, there's gotta be something there).  But I also want to know how to connect my robot to large systems, such as a Raspberry Pi, PC, or the whooooole Internet.  And to it do it effectively I need to be able to pass data between procedural and object programs.

### Avoiding Sleep

<img height="220" width="320" style="float: left; margin: 10px;" src="http://www.frugal-cafe.com/public_html/frugal-blog/frugal-cafe-blogzone/wp-content/uploads/2010/11/coffee-smiley-face-ballistik-coffee-boy-flickr.jpg">

One bit I noticed writing in OOP is it usually takes full advantage of [threading](https://en.wikipedia.org/wiki/Thread_%28computing%29).  Most microcontrollers have one core (yes, yes, except the Parrallax), so threading is not something done often on a microcontroller.  But my program is walking between the microcontroller world and the big-boy-PC world.  As I stated above, at some point the HM-1X module, more specifically the CC254X the Texas Instrument chip at the heart of the HM-1X, would need to pass its data to the PC.  

Here in lies a dilemma best explained by a picture,

<img height="277" width="640" style="margin: 10px;" src="/images/threadingCars.png">

For the HM-1X Aid the data is passed through the Serial connection.  Of course, as I stated above, I am using the Systems.IO.Ports.SerialPorts framework to handle the incoming serial data.  A nifty little aspect of IO.Ports is it actually has the [DataReceivedEvent](https://msdn.microsoft.com/en-us/library/system.io.ports.serialport.datareceived%28v=vs.110%29.aspx) on a separate thread.  This event is triggered by an RX interrupt on whatever USB-to-UART chip the IO.Ports is working with.  This allows data to be handled as it is coming in.  Excellent.  (Coincdentally, iOS handles Bluetooth in the CoreBluetooth with an interrupt, but it will only be on a separate thread if setup as such.)

Now, I mentioned at some point methods for handling data probably go from procedural to object-oriented when moving upstream from a microcontroller to a PC.  A USB-to-UART bridge is a perfect example.  Receiving UART data for a microntroller looks like this,

{% highlight c %}
int incomingByte = 0;   // for incoming serial data

void setup() {
        Serial.begin(9600);     // opens serial port, sets data rate to 9600 bps
}

void loop() {

        // send data only when you receive data:
        if (Serial.available() > 0) {
                // read the incoming byte:
                incomingByte = Serial.read();

                // say what you got:
                Serial.print("I received: ");
                Serial.println(incomingByte, DEC);
        }
}
{% endhighlight %}

Basically, the microcontroller is looping over a check to see if there is any data available in the RX buffer.  Whenever the `loop()` finds there are available data, then it will run through some procedures on handling those data.  This method works perfectly fine, if all your microcontroller is doing is serial data centric.  But what happens if your microcontroller is has a never-ending stream of data?  Whatever code is after the `if(Serial.available() > 0)` will never execute, since the available serial data will never be less than 0.  This is referred to as using a "blocking" serial data method.  I'm thinking "blocking" means it is preventing the code from doing anything else


Hmm, wouldn't be better to handle serial data "immediately" when it comes in?  That's where interrupts come in.  

The `Serial.onReceive()` is an interrupt vector which fires every time the serial data comes in.  It then stores it then copies the data received from the interrupt buffer into the `string_buffer`.

{% highlight c %}
void MyFunction(){
   int i;
   int length = Serial.available();
   int string_buffer[32];   

   //copy data out of the receive buffer
   for(i = 0; i < length; i++){
      string_buffer[i] = Serial.read();
   }

   //run a string compare function, or otherwise parse the received data
   if(MySpecialStingCompare(string_buffer,"Hello Arduino")){
      Serial.println("Hello World");
   }
}

void setup(){
   Serial.begin(9600);
   Serial.onReceive(MyFunction);
}

void loop(){
   //do nothing
}

{% endhighlight %}

This is a non-blocking method of handling serial data.  It takes advantage of a hardware level peripheral on the Atmel chips known as a [interrupt vector](https://en.wikipedia.org/wiki/Interrupt_vector_table).  This particular interrupt is fired any time the RX pin receives a series of LOWs which resemble incoming data.  

This method has the advantage of freeing the main processor to do other things in the main loop and handle data _only_ when new data is received.  This saves us from having to make a comparison every clock cycle.  Also, and more importantly, it allows the microcontroller to immediately update data important to the purpose of the main process; this is critical in processes which are time sensitive, such as remote control on a quadcopter.

For example, if we wrote a radio controller for our quadcopter using a Bluetooth device which talks to an Arduino Pro Mini.  If we used the blocking method the Arduino receives any data from the radio controller, like, oh I don't know, "Don't run into that tree!" the main process on the Arduino would not have this information until it gets back to the `Serial.available() > 0`.  Not cool, if milliseconds matter.

However, if you were to write the same radio controller using non-blocking, interrupt based serial communication, then whenever you send the signal to the Bluetooth device, and that device sends it serially to the Arduino, the Arduino will basically bookmark its place in the main process and handle any data regarding its immediate crash.

Good stuff.

Alright, so that's how a microcontroller handles things procedurally--but what does this have to do with my C# program? I dunno, I'm DATKing this article.

Let's take a look at C\#, though.

{% highlight c# %}
string InputData = "";

// Read Data.
private void DataReceivedHandler(object sender, SerialDataReceivedEventArgs e)
{
    // Gets incoming data from open port and passes it to a handler.
    InputData = ComPort.ReadExisting();
    captureBuffer = InputData;
    captureBuffer = "";

}

{% endhighlight %}

This is probably the simplest version of a `DataReceivedHandler()` using C\#.  In short, it fires whenever data is received; so it's non-blocking.  The method as I have it written simply grabs the data from the interrupt buffer using `ComPort.ReadExisting()` and shoves it into the `inputData`.  Pretty simple, right?  And it is, which is one reason I think so many [poo-poo](http://www.sparxeng.com/blog/software/must-use-net-system-io-ports-serialport) using IO.Ports.SerialPort framework.  But how is different than the [http://hackaday.com/2015/10/20/the-case-for-arduino-in-real-engineering/](Arduino HAL) `Serial.onReceive()`?  The main difference is the the C\# is actually on a separate thread from the main thread.

Now, I'm going to dare to oversimplify what little understanding regarding threads.  For this article, I would like to think of a thread as a separate process within our system.  Of course, we can't call the second process, "main process".  We've already got one of those. And computers don't like ambiguity.  Instead, let's get creative and call the second process something wild, fun, and bizarre! Like..."second process".

Since we have cleared up definitions let's talk about how this is different than the Arduino HAL.  In C\# the second process is pretty much like the main process.  There _is_ a lot of complexity to it, but the compiler takes care of most of it.  With one grand honking exception: The user interface (UI) runs on the main process and cannot be updated by any other process.  Instead, a protocol saving data in a space both processes can access it and a flag to look in the shared space when updated.  This is the good old snail-mail mailbox where the flag is raised when you want the post-person to look for letter.

Bringing it back to my code.  The HM-1X's serial DataReceivedEvent is on one process and my UI is on another.  This means, when my program gets some data serially then it puts that data in the shared space and lets the UI know there data has been received.  

Those of you who are sharper than me (all of you?) will notice an issue.  If the data coming in and the UI are working out of sync what happens if a user does something like continually hit the Send on a command without waiting for a serial response to be received.  The best case scenario is we got an "OK" for every time the command was sent.  However, if it is a more complicated command which requires a back-and-forth conversation between the microcontroller and the desktop, well, big problems.  It would be like a [https://www.youtube.com/watch?v=yCOPJi0Urq4()]sloth and a hare trying to have a conversation).  Those of you from the Arduino world know the common (however, I'll argue not best) answer to this dilemma: `delay()`.

The `delay()` in the Arduino HAL basically tells the microcontroller to do nothing for however long you tell it.  This allows the message to go across UART-to-USB and back and _then_ look for the answer.  But this is poor design.  I'm not focusing on how to do this in the Arduino HAL, but I'll say, it involves interrupts and good code.  But let's take a look at what happens when you are trying to update Arduino's version of a UI the LED display.

{% highlight c %}

#include <LiquidCrystal_I2C.h>

/*-----( Declare Constants )-----*/
/*-----( Declare objects )-----*/
// set the LCD address to 0x27 for a 16 chars 2 line display
// A FEW use address 0x3F
// Set the pins on the I2C chip used for LCD connections:
//                    addr, en,rw,rs,d4,d5,d6,d7,bl,blpol
LiquidCrystal_I2C lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);  // Set the LCD I2C address

/*-----( Declare Variables )-----*/
//NONE

void setup()   /*----( SETUP: RUNS ONCE )----*/
{
  Serial.begin(9600);  // Used to type in characters

  lcd.begin(16,2);   // initialize the lcd for 16 chars 2 lines, turn on backlight

// ------- Quick 3 blinks of backlight  -------------
  for(int i = 0; i< 3; i++)
  {
    lcd.backlight();
    delay(250);
    lcd.noBacklight();
    delay(250);
  }
  lcd.backlight(); // finish with backlight on  

//-------- Write characters on the display ------------------
// NOTE: Cursor Position: (CHAR, LINE) start at 0  
  lcd.setCursor(0,0); //Start at character 4 on line 0
  lcd.print("Hello, world!");
  delay(1000);
  lcd.setCursor(0,1);
  lcd.print("HI!YourDuino.com");
  delay(8000);  

// Wait and then tell user they can start the Serial Monitor and type in characters to
// Display. (Set Serial Monitor option to "No Line Ending")
  lcd.clear();
  lcd.setCursor(0,0); //Start at character 0 on line 0
  lcd.print("Use Serial Mon");
  lcd.setCursor(0,1);
  lcd.print("Type to display");  


}/*--(end setup )---*/


void loop()   /*----( LOOP: RUNS CONSTANTLY )----*/
{
  {
    // when characters arrive over the serial port...
    if (Serial.available()) {
      // wait a bit for the entire message to arrive
      delay(100);
      // clear the screen
      lcd.clear();
      // read all the available characters
      while (Serial.available() > 0) {
        // display each character to the LCD
        lcd.write(Serial.read());
      }
    }
  }

}/* --(end main loop )-- */


/* ( THE END ) */

{% end highlight %}

1. Can't update UI when main process is busy.  Arduino and not updating an OLED until finished with Serial data.
2. Advantages of interrupts; received data immediately added to main process
3. Advantage of threads; off-load clock cycle intensive operations to a different process to maintain responsiveness of UI and other main process fun.


One last note, I started porting this to Mac and Linux using MonoDevelopment, but it would require writing my own interrupt handler.  Or faking it with a timeout method.  Nether option is worth it to me.  Too many other projects and too little time.
