---
layout: article
title: HM-1X Aid
categories: robots
excerpt:
tags: [robots]
color: "#152a55"
image:
  feature: HM-10-2.jpg
  teaser: HM-10-2.jpg
  thumb:
comments: true
---

## HM-1X Aid Overview

Well, I've had the urge to hack.  It's been strong for awhile now, sadly, with a more than fullt-time job and Bek in graduate school, I've just had no time.  **Until now!**  The new job I have (HMIS Database Manager) has _actual_ vacation time.  I've had almost two weeks off (combined with the Christmas holiday).  The first few days were obviously spent working...**But!** After turning my phone and email (the work email) I was able to...catch up on family time.  Sigh.  Then, clean house.  Then, get bored.  But with a few days left I actually got some hacking in.

I downloaded Visual Studio Express on my work computer a few months ago.  (Shh.  Don't tell the boss.) But I've not had time to write a single line of code.  This holiday was a good time to learn C\#!

Two weeks later I had this monster,

<div class="flex-video">
<iframe width="420" height="315" src="https://www.youtube.com/embed/XtrS7ENc1EU" frameborder="0" allowfullscreen></iframe>
</div>

It is meant to be a GUI for the HM-10, HM-11, and HM-15 modules.  The highlights,

[HM-1X Aid Download](https://github.com/Ladvien/HM-1X-Build/raw/master/setup.exe)

The source can be found,

[HM-1X Aid Source](https://github.com/Ladvien/HM-1X_Aid_v01)

1. It uses threads to prevent any "Sleeping."  Keeps the UI healthy.
2. IO.SerialPorts _should_ allow a lot of USB-to-UART chips to work.
3. Basic Terminal App features (view as ASCII, HEC, Decimal, etc.) like RealTerm and the others. BUT! With one feature I've longed for in a terminal app for so damn long.  The ability to save your settings on exit.  No more selecting 9600 baud for the billionth time.
4. I've put a lot of command validity checks in the system.  For example, if you were to type "AT+CON0123**S**6789012" Would not be a valid command normally, but terminal will convert the "S" to "F."
5. I have also imbued it with a bit my understanding of the HM-1X datasheets.  This is probably the greatest selling point of the program, sadly.
6. **C# is my new favorite.  Don't judge me :P.**

I thought I would take some time to go into the code involved in the little terminal, not for posterity, merely for my own reference.

**"Attention .NET Users! This is the law. Disperse immediately, or we will use lethal force to clear the area. You have been warned. You now have 20 seconds to comply..."**


![](http://www.geek.com/wp-content/uploads/2015/09/stallone-judge-dredd-590x332.jpg)


## Object Oriented Programming

I have post as much lately.  I think it is a combination of losing LMR and not having time since Bek started school.  But I have definitely been writing code.  The focus has been on learning OOP design.  This this C\# program was probably my first _real_ object-oriented program.  But I have also been writing in [Swift](https://developer.apple.com/ios/?cid=wwa-us-kwg-features) for iOS, which is an OOP language as well.

Arlight, so what's the difference between OOP and the other thing? And why learn OOP, I thought robot used microcontollers whichi are much too small to handle OOP?

Well, as I've learned, every robot builder is _already_ an object oriented programmer.

#### Difference between OOP and Procedural programming

I will not attempt to explain more poorly what I've learned, rather, I'm going to list what has helped me get a better understanding.

1. [Object-Oriented programming](https://www.youtube.com/watch?v=lbXsrHGhBAU) (video)
2. [Procedural Programming](https://www.youtube.com/watch?v=b4n9KYD05jg) (video)
3. [Derek Banas' Design Patterns Series](https://www.youtube.com/watch?v=vNHpsC5ng_E&list=PLF206E906175C7E07) (examples in Java, but it helped me the most.  Got to see OOP in action.)

I believe every roboticist is both an object oriented programmer and a procedural programmer.  

They create objects with specific functions (PCBs, STLs, etc.), retaining the plans to make copies of such objects in the future.  They instantiate those objects (print the STL, send the PCB file to OSHPark, etc.)  Each of these objects created usually has a specific purpose.  The design of the object, for instance the motor-controller, is often only accessible by a specific input such as the UART connection.  And its outputs are controlled by how the inputs are digested by the motor-controller itself. The robot may decide to add an accelerometer to the motor-controller by copying the design files and adding the needed accelerometer circuit (inheritance).  It seems like all the concepts are there,
1. [Abstraction](https://en.wikipedia.org/wiki/Abstraction_%28computer_science%29)
2. [Encapsulation](https://en.wikipedia.org/wiki/Encapsulation_%28computer_programming%29)
3. [Polymorhphism](https://en.wikipedia.org/wiki/Polymorphic_code)
4. [Inheritance](https://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29)

However, each roboticist must line the insides of their objects with procedures that move data through in a predictable manner.  This means, at some granularity point, objects are filled with small runs of procedural programming (I realize Procedural Programming and programming procedural are not the same, but hey, it's my article).

Moving away from the hippy-dippy stuff; for my personal development as a robot builder I will be taking the time learn both, since they both seem roots of computational-thinking.

In application, I want to know procedural programming since microcontrollers often have small memory sets, and the code needs to move from input to objective with as little overhead as possible (Hmm, procedural programming is a linear programming style and line is the shortest distance between two points, there's gotta be something there).  But I also want to know how to connect my robot to large systems, such as a Raspberry Pi, PC, or the whooooolllee Internet.  And to do that effectively I will need to translate procedural to object programming at _some_ point.

## Avoiding Sleep

<a href="http://gulpjs.com">
  <img height="220" width="320" style="float: left; margin: 10px;" src="http://www.frugal-cafe.com/public_html/frugal-blog/frugal-cafe-blogzone/wp-content/uploads/2010/11/coffee-smiley-face-ballistik-coffee-boy-flickr.jpg">
</a>

One bit I noticed writing in OOP is it usually takes full advantage of [threading](https://en.wikipedia.org/wiki/Thread_%28computing%29).  Most microcontrollers have one core (yes, yes, except the Parrallax), so threading is not something done often on a microcontroller.  But my program was walking between the microcontroller world and the big-boy-PC world.  As I stated above, at some point the HM-1X module, more specifically the CC254X the Texas Instrument chip at the heart of the HM-1X, would need to pass its data to the PC.  The data is passed through the Serial connection.  Of course, as I stated above, I am using the Systems.IO.Ports framework to handle the incoming serial data.  A nifty little aspect of IO.Ports is it actually has the DataReceivedEvent on a separate thread.  This event is triggered by an RX interrupt on whatever USB-to-UART chip the IO.Ports is working with.  This allows data to be handled as it is coming in.  

Now, I mentioned at some point methods for handling data probably go from procedural to object-oriented when moving upstream from a microcontroller to a PC.  This is a perfect example.  Receiving data for a 




One last note, I started porting this to Mac and Linux using MonoDevelopment, but it would require writing my own interrupt handler.  Or faking it with a timeout method.  Nether option is worth it to me.  Too many other projects and too little time.
