I"òM<h2 id="comparative-functions">Comparative Functions</h2>
<p>Comparing two or more values is an extremely important concept when talking to computers.  In writing a report script, it is is essential.  Comparisons allow us to filter to values within a range, allowing us to provide a report of relevant information.</p>

<p>Take the following data:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1">######################### Data ###################################</span><span class="w">
</span><span class="c1">###################### DO NOT CHANGE #############################</span><span class="w">
</span><span class="n">peopleDf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">PersonalID</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"ZP1U3EPU2FKAWI6K5US5LDV50KRI1LN7"</span><span class="p">,</span><span class="w"> </span><span class="s2">"IA26X38HOTOIBHYIRV8CKR5RDS8KNGHV"</span><span class="p">,</span><span class="w"> </span><span class="s2">"LASDU89NRABVJWW779W4JGGAN90IQ5B2"</span><span class="p">),</span><span class="w"> 
           </span><span class="n">FirstName</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"Timmy"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Fela"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Sarah"</span><span class="p">),</span><span class="w">
           </span><span class="n">LastName</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"Tesa"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Falla"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Kerrigan"</span><span class="p">),</span><span class="w">
           </span><span class="n">DOB</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"2010-01-01"</span><span class="p">,</span><span class="w"> </span><span class="s2">"1999-1-1"</span><span class="p">,</span><span class="w"> </span><span class="s2">"1992-04-01"</span><span class="p">))</span><span class="w">
</span><span class="c1">##################################################################</span><span class="w">
</span><span class="c1">##################################################################</span></code></pre></figure>

<p>If you run the above in R you should get a dataframe called <code class="highlighter-rouge">peopleDf</code> which looks like this:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">PersonalID</th>
      <th style="text-align: left">FirstName</th>
      <th style="text-align: left">LastName</th>
      <th style="text-align: left">DOB</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">ZP1U3EPU2FKAWI6K5US5LDV50KRI1LN7</td>
      <td style="text-align: left">Timmy</td>
      <td style="text-align: left">Tesa</td>
      <td style="text-align: left">2010-01-01</td>
    </tr>
    <tr>
      <td style="text-align: left">IA26X38HOTOIBHYIRV8CKR5RDS8KNGHV</td>
      <td style="text-align: left">Fela</td>
      <td style="text-align: left">Falla</td>
      <td style="text-align: left">1999-1-1</td>
    </tr>
    <tr>
      <td style="text-align: left">LASDU89NRABVJWW779W4JGGAN90IQ5B2</td>
      <td style="text-align: left">Sarah</td>
      <td style="text-align: left">Kerrigan</td>
      <td style="text-align: left">1992-04-01</td>
    </tr>
  </tbody>
</table>

<p>It‚Äôs a simple table.  But let‚Äôs say we wanted to get a list of everyone born before 2000-01-01.  Of course, we can easily see Timmy is the only person born after 2000. But if our table was thousands of records it wouldn‚Äôt be possible to quickly assess.</p>

<p>Luckily, this is pretty straight forward in SQL-R.  We will use a <code class="highlighter-rouge">less than operator</code> (<strong>&lt;</strong>).  You probably remember this sign from high-school while solving inequalities.  However, we will be using it as what‚Äôs known as a <a href="https://en.wikipedia.org/wiki/Relational_operator">relational operator</a>.</p>

<p>In short, it states,</p>

<blockquote>
  <p>Is x less than y</p>
</blockquote>

<p>If <code class="highlighter-rouge">x is less than y</code> the computer is going to say the statement is true (or 1 in binary).  If it is not, then the computer will say it‚Äôs false (or 0 in binary).  Believe it or not, this simple operation is why you have a device in your pocket which could calculate the internal mass of the sun.</p>

<p>For us, things are a little simpler.  We just want to know who was born before 2000.  Let‚Äôs re-write the statement above with our problem:</p>

<blockquote>
  <p>Is Sarah‚Äôs DOB less than 2000-01-01</p>
</blockquote>

<p>Well, what is Sarah‚Äôs DOB? 1992-04-01.  Let‚Äôs rewrite and assess (gah, this feels like high-school algebra again).</p>

<blockquote>
  <p>Is 1992-04-01 less than 2000-01-01</p>
</blockquote>

<p>Hmm.  This can get confusing for humans, but more importantly, confusing to computers.</p>

<p>In English, we‚Äôd probably state this as,</p>

<blockquote>
  <p>Did 1992-04-01 come before 2001-01-01?</p>
</blockquote>

<p>Essentially, that‚Äôs what we are doing.  Just know, the computer will translate all dates into a number.  This number is how many seconds transpired since 1970-01-01.</p>

<p>Why? On Thursday, January 1st 1970 the <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">Universal Coordinated Time</a> (UTC) was established.  Think of it is when the world came together to standardize time.  Computer people figured, ‚ÄúWell, if we have to convert dates into a raw number for computers to understand it, it might as well be the number of seconds since UTC was established.‚Äù</p>

<p>Ok, enough history lesson.  How is this relevant?</p>

<ol>
  <li>Computers convert dates into seconds since 1970-01-01.</li>
  <li>Comparing dates is actually comparing numbers.</li>
</ol>

<p>Taking our statement again, let‚Äôs re-write it with the number of seconds since <code class="highlighter-rouge">1970-01-01</code></p>

<blockquote>
  <p>Is number of seconds between 1970-01-01 and 1992-04-01 less than number of seconds between 1970-01-01 and 2000-01-01</p>
</blockquote>

<p>Which becomes:</p>

<blockquote>
  <p>Is 702,086,400 less than 46,684,800 seconds</p>
</blockquote>

<p>Aha, now this makes sense.  And the result is <code class="highlighter-rouge">true</code>.  We can now say, in computer speak: Sarah was born before <code class="highlighter-rouge">2000-01-01</code>.</p>

<h3 id="why--really-dude">Why?  Really, dude.</h3>
<p>In my world there is a saying: <a href="https://en.wikipedia.org/wiki/RTFM">RFTM</a>.</p>

<p>It‚Äôs hard to follow now days.  Everything moves quick and we don‚Äôt have time to dig into the ‚ÄúWhy.‚Äù  But, like most things, if you want to be good, you must take the time to do so.</p>

<p>The reason we review how computers understand dates is it directly impacts how we write reports.  Do you remember the <a href="https://ladvien.com/sqldf-dates/">date conversion trick</a> to get dates to work in SQL from R? This is because R holds dates as the number of seconds since 1970 and passes it as a string to SQL.  But, then SQL tries to convert the date from a date into seconds again, screwing everything up.</p>

<p>It pays to RFTM.</p>

<h2 id="filtering-dataframes-by-date">Filtering Dataframes by Date</h2>
<p>Back to the problem.  How do we write a script which provides a dataframe of people born before 2000-01-01?</p>

<p>The code is actually pretty simple,</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">library</span><span class="p">(</span><span class="n">sqldf</span><span class="p">)</span><span class="w">
</span><span class="n">nonMillennialsDf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT * FROM peopleDf WHERE DOB &lt; '2000-01-01'"</span><span class="p">)</span></code></pre></figure>

<p>This should provide a <code class="highlighter-rouge">nonMillennialsDf</code> dataframe, which contains:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">PersonalID</th>
      <th style="text-align: left">FirstName</th>
      <th style="text-align: left">LastName</th>
      <th style="text-align: left">DOB</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">IA26X38HOTOIBHYIRV8CKR5RDS8KNGHV</td>
      <td style="text-align: left">Fela</td>
      <td style="text-align: left">Falla</td>
      <td style="text-align: left">1999-1-1</td>
    </tr>
    <tr>
      <td style="text-align: left">LASDU89NRABVJWW779W4JGGAN90IQ5B2</td>
      <td style="text-align: left">Sarah</td>
      <td style="text-align: left">Kerrigan</td>
      <td style="text-align: left">1992-04-01</td>
    </tr>
  </tbody>
</table>

<p>And there we go, for all my nerdsplaining the code‚Äôs pretty simple, right?</p>

<p>Well, there are a few gotchas.  Notice the date we‚Äôve written.  It has the following format <code class="highlighter-rouge">YYYY-MM-DD</code> and is surrounded by single quotes.  Any time you use dates in SQL they must be written in this format.</p>

<p>Another tricky part is trying to find if a date falls between two dates.  Let‚Äôs take the <code class="highlighter-rouge">peopleDf</code> and write a query which provides everyone who was born between <code class="highlighter-rouge">1998-01-01</code> and <code class="highlighter-rouge">2005-01-01</code></p>

<p>Here‚Äôs the query.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">bornBetweenDf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT * FROM peopleDf WHERE DOB &gt; '1998-01-01' AND DOB &lt; '2005-01-01'"</span><span class="p">)</span><span class="w"> </span></code></pre></figure>

<p>This should result in a table with only Fela:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">PersonalID</th>
      <th style="text-align: left">FirstName</th>
      <th style="text-align: left">LastName</th>
      <th style="text-align: left">DOB</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">IA26X38HOTOIBHYIRV8CKR5RDS8KNGHV</td>
      <td style="text-align: left">Fela</td>
      <td style="text-align: left">Falla</td>
      <td style="text-align: left">1999-1-1</td>
    </tr>
  </tbody>
</table>

<p>It is important to understand, the first comparison removed Sarah, as <code class="highlighter-rouge">1992-04-01</code> is less than <code class="highlighter-rouge">1998-01-01</code>.  Then, the second comparison got rid of Timmy as <code class="highlighter-rouge">2010-01-01</code> is greater than <code class="highlighter-rouge">2005-01-01</code>.</p>

<h2 id="now">Now()</h2>
<p>There is one more critical command in writing robust date comparisons.  The <code class="highlighter-rouge">NOW()</code> function.  This function is different in R and SQL, but pretty much every programming language has a version of the function.</p>

<p>Essentially, the <code class="highlighter-rouge">NOW()</code> asks the computer what today‚Äôs date is when the script runs.</p>

<p>In SQL-R it looks like this:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">nowDf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT *, DATE('NOW') As 'TodaysDate' FROM peopleDf"</span><span class="p">)</span></code></pre></figure>

<p>This should provide:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">PersonalID</th>
      <th style="text-align: left">FirstName</th>
      <th style="text-align: left">LastName</th>
      <th style="text-align: left">DOB</th>
      <th style="text-align: left">TodaysDate</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">ZP1U3EPU2FKAWI6K5US5LDV50KRI1LN7</td>
      <td style="text-align: left">Timmy</td>
      <td style="text-align: left">Tesa</td>
      <td style="text-align: left">2010-14-01</td>
      <td style="text-align: left">2017-07-18</td>
    </tr>
    <tr>
      <td style="text-align: left">IA26X38HOTOIBHYIRV8CKR5RDS8KNGHV</td>
      <td style="text-align: left">Fela</td>
      <td style="text-align: left">Falla</td>
      <td style="text-align: left">1999-1-1</td>
      <td style="text-align: left">2017-07-18</td>
    </tr>
    <tr>
      <td style="text-align: left">LASDU89NRABVJWW779W4JGGAN90IQ5B2</td>
      <td style="text-align: left">Sarah</td>
      <td style="text-align: left">Kerrigan</td>
      <td style="text-align: left">1992-04-01</td>
      <td style="text-align: left">2017-07-18</td>
    </tr>
  </tbody>
</table>

<p>And it doesn‚Äôt matter when this script is run, it will always insert today‚Äôs date in the <code class="highlighter-rouge">TodaysDate</code> column.  Nifty, right?  Trust me, if you don‚Äôt see the possibilities yet, give it time.  It‚Äôll grow into one of your favorite functions.</p>

<p>Well, we can‚Äôt talk about the <code class="highlighter-rouge">NOW()</code> function without discussing the <code class="highlighter-rouge">DATE()</code> function I slipped in there.  What does it do?</p>

<p>As we discussed earlier, the computer looks at dates as the number of seconds since <code class="highlighter-rouge">1970-01-01</code>.  When you use the <code class="highlighter-rouge">NOW()</code> function by itself then it will return the number of seconds‚Äìum, not something humans like to read.  The <code class="highlighter-rouge">DATE()</code> function says, ‚ÄúTake whatever is inside the parentheses and try to convert it into a human readable date.‚Äù  <em>Voila!</em> A human readable date.</p>

<h2 id="age">Age</h2>
<p>Let‚Äôs get fancy.  We can use the <code class="highlighter-rouge">NOW()</code> function and our <code class="highlighter-rouge">peopleDf</code> to calculate everyone‚Äôs age.</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="n">peopleWithAgeDf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT *, (DATE('NOW') - DOB) As 'Age' FROM peopleDf"</span><span class="p">)</span></code></pre></figure>

<p>This should provide:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">PersonalID</th>
      <th style="text-align: left">FirstName</th>
      <th style="text-align: left">LastName</th>
      <th style="text-align: left">DOB</th>
      <th style="text-align: right">Age</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">ZP1U3EPU2FKAWI6K5US5LDV50KRI1LN7</td>
      <td style="text-align: left">Timmy</td>
      <td style="text-align: left">Tesa</td>
      <td style="text-align: left">2010-14-01</td>
      <td style="text-align: right">7</td>
    </tr>
    <tr>
      <td style="text-align: left">IA26X38HOTOIBHYIRV8CKR5RDS8KNGHV</td>
      <td style="text-align: left">Fela</td>
      <td style="text-align: left">Falla</td>
      <td style="text-align: left">1999-1-1</td>
      <td style="text-align: right">18</td>
    </tr>
    <tr>
      <td style="text-align: left">LASDU89NRABVJWW779W4JGGAN90IQ5B2</td>
      <td style="text-align: left">Sarah</td>
      <td style="text-align: left">Kerrigan</td>
      <td style="text-align: left">1992-04-01</td>
      <td style="text-align: right">25</td>
    </tr>
  </tbody>
</table>

<p>Cool, right?  Now, it does not matter when this above code of line is run, it will calculate everyone‚Äôs age correctly.</p>

<p><strong>One important note,</strong> if the date and time are wrong on your computer this calculation will be incorrect.</p>

<p>The nerd-judo which can be done with dates in SQL-R is endless.  But this covers a lot of the basics.</p>

<p>If you‚Äôve missed the code bits throughout this article, here it is all at once:</p>

<figure class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1">######################### Data ###################################</span><span class="w">
</span><span class="c1">###################### DO NOT CHANGE #############################</span><span class="w">
</span><span class="n">peopleDf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">data.frame</span><span class="p">(</span><span class="n">PersonalID</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"ZP1U3EPU2FKAWI6K5US5LDV50KRI1LN7"</span><span class="p">,</span><span class="w"> </span><span class="s2">"IA26X38HOTOIBHYIRV8CKR5RDS8KNGHV"</span><span class="p">,</span><span class="w"> </span><span class="s2">"LASDU89NRABVJWW779W4JGGAN90IQ5B2"</span><span class="p">),</span><span class="w"> 
           </span><span class="n">FirstName</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"Timmy"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Fela"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Sarah"</span><span class="p">),</span><span class="w">
           </span><span class="n">LastName</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"Tesa"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Falla"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Kerrigan"</span><span class="p">),</span><span class="w">
           </span><span class="n">DOB</span><span class="o">=</span><span class="nf">c</span><span class="p">(</span><span class="s2">"2010-14-01"</span><span class="p">,</span><span class="w"> </span><span class="s2">"1999-1-1"</span><span class="p">,</span><span class="w"> </span><span class="s2">"1992-04-01"</span><span class="p">))</span><span class="w">
</span><span class="c1">##################################################################</span><span class="w">
</span><span class="c1">##################################################################</span><span class="w">
</span><span class="n">library</span><span class="p">(</span><span class="n">sqldf</span><span class="p">)</span><span class="w">
</span><span class="n">nonMillennialsDf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT * FROM peopleDf WHERE DOB &lt; '2000-01-01'"</span><span class="p">)</span><span class="w">
</span><span class="n">bornBetweenDf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT * FROM peopleDf WHERE DOB &gt; '1998-01-01' AND DOB &lt; '2005-01-01'"</span><span class="p">)</span><span class="w"> 
</span><span class="n">nowDf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT *, DATE('NOW') As 'TodaysDate' FROM peopleDf"</span><span class="p">)</span><span class="w">
</span><span class="n">peopleWithAgeDf</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">sqldf</span><span class="p">(</span><span class="s2">"SELECT *, (DATE('NOW') - DOB) As 'Age' FROM peopleDf"</span><span class="p">)</span></code></pre></figure>
:ET