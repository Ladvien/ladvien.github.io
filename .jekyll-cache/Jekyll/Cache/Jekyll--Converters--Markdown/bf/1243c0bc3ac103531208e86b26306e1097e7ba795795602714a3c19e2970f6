I"u‹<p>This is a continuation of my <a href="http://letsmakerobots.com/node/39996">Robot Metallurgy 101 ‚Äì AVR Lesson Journal</a></p>

<ul>
  <li><a href="https://github.com/Ladvien/ATtiny1634_AVR_Code">USART_1634 Code Github</a></li>
</ul>

<p><strong>UPDATE: Now with UART(ish)! (3/2/2014)</strong></p>

<ol>
  <li><strong>Robot Metallurgy 101: <a href="http://letsmakerobots.com/node/40483">PWM</a></strong></li>
  <li><strong>Robot Metallurgy 101: <a href="http://letsmakerobots.com/node/40501">UART</a></strong></li>
</ol>

<p>I thought I would journal my work as I begin to venture from the comfortable playground of Arduino C and IDE.</p>

<p>I‚Äôve tried a few other IDEs and C++ to work with different chips.  But each time I realize I don‚Äôt know enough about C/C++, tool-chains, and workspaces to make a robot with them.</p>

<p>Bdk6 gave me an LCP1114 and I was able to get a blink program to run on it, but it was from a .bin file that someone else compiled, I simply uploaded it.  I tried to work through two walkthroughs to get a programming environment setup (mbed and LPC1114).  Bust on both.</p>

<p>I spent some time Googling, trying to find out what I was doing wrong.  I came to the conclusion there was not enough information for an ignorant like me to figure out how to set up the workspace; the LPC1114 is an intermediate chip and I‚Äôm a beginner.</p>

<p>I decided to pull up tutorials on AVR programming.  I knew there was an entire community around the Atmel chips, a community besides the Arduino community, a bare-metal community.  I figured that would be the ‚Äúbeginner‚Äù environment to work in, since there would be enough documentation for me to learn</p>

<p>So, that brings us to my journal.  I‚Äôve not written this out to impress anyone.  I simply find I learn better if I force myself to document what I‚Äôm doing.  It encourages me to understand the information, since I have to explain it to someone else.  Learning by verbal-processing. That being said, I invite criticism.  Anything I‚Äôve written that is incorrect, feel free to yell at me; it‚Äôll learn me.  Also, a lot of this has been written; I know I‚Äôm not being original. I‚Äôm also not delusional in believing I explain it better, but I do plan on making this journal flow towards how AVR programming can help me build better robots.  Ok. Disclaimer done.</p>

<p>I ordered a few samples of the <a href="http://www.atmel.com/Images/Atmel-8303-8-bit-AVR-Microcontroller-tinyAVR-ATtiny1634_Datasheet.pdf">ATtiny1634</a>.</p>

<p><img src="../images/ATtiny_1634.jpg" alt="" /></p>

<p>A long time ago I bought an <a href="http://store.atmel.com/PartDetail.aspx?q=p:10500054#tc:description">AVR ISP MKII</a> to program <a href="http://letsmakerobots.com/node/36273">these boards</a></p>

<p><img src="../images/AVR_ISP_MKII.jpg" alt="" /></p>

<p>I wired up the 1634 and the ISP like so,</p>

<p><img src="../images/1634_to_ISP.jpg" alt="" /></p>

<p>What do you mean the silk-screen is mislabeled‚Ä¶shh.</p>

<p>After I got the pinout all figured out, I downloaded <a href="http://www.atmel.com/tools/atmelstudio.aspx">Atmel Studio 6.1</a>.  I know there are many different opinions about what IDE to use, and a lot of them seem to favor a text editor and AVRDude, for a change I wanted to go with a commercial IDE.  Also, it seems like a lot of those in the AVRFreaks group actually <em>like</em> Atmel Studio.</p>

<p>It‚Äôs pretty easy to set up.  You install it.  Plug in your AVR ISP MKII.  Then, File‚Äì&gt;New Project.  Select ‚ÄúGCC C Executable Project‚Äù and name your project.  Hit ‚ÄúOk.‚Äù  Atmel Studio will bring up a list of supported chips.  I scrolled down until I found my chip, ‚ÄúATtiny1634.‚Äù You‚Äôll notice the <a href="http://www.atmel.com/Images/Atmel-8303-8-bit-AVR-Microcontroller-tinyAVR-ATtiny1634_Datasheet.pdf">datasheet</a> and supported programmers are to the side.</p>

<p>Alright, so, here I was.  IDE all set up‚Ä¶um, now what do I do?</p>

<p>I began to Google until I found an AVR Tutorial Series that looked like it would bring me from the basics, well, up to Serial communication.  Really, I figure if I could learn the following I could build whatever I wanted out of it:</p>

<ol>
  <li>Digital pin control (HIGH/LOW).</li>
  <li>ADC.</li>
  <li><a href="http://letsmakerobots.com/node/40483">PWM</a></li>
  <li>Library creation.</li>
  <li><a href="http://letsmakerobots.com/node/40501">UART</a>.</li>
  <li>I2C.</li>
</ol>

<p>Luckily, I found the series put together by <a href="http://www.newbiehack.com/">Newbie Hack‚Äôs</a> series.</p>

<p><a href="http://www.newbiehack.com/"><img src="http://www.newbiehack.com../images/newbieHack_logo_04CroppedscaledTo200.jpg" alt="" /></a></p>

<p>So, I decided I would try to walk through all of his tutorials and see if I could apply them to the ATtiny1634. NOTE: The author of this series appears to be <a href="http://www.newbiehack.com/aboutus.aspx">Patrick Hood-Daniel</a>, a fellow Texan (don‚Äôt hold that against us :P).</p>

<p><strong>1. Blinkin LED</strong></p>

<p>Newbie Hack‚Äôs <a href="http://www.newbiehack.com/MicrocontrollerWritingthefirstprogramandtransfer.aspx">MCU First Program</a>.</p>

<p>I started Newbie Hack‚Äôs AVR Series after he had his programmer setup, his ‚ÄúFirst Program.‚Äù  The uC‚Äôs version of the ‚Äúhello world,‚Äù the LED blink.  In Arduino I‚Äôd accomplish this like so,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">led</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">led</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">led</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>   <span class="c1">// turn the LED on (HIGH is the voltage level)</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>               <span class="c1">// wait for a second</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">led</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>    <span class="c1">// turn the LED off by making the voltage LOW</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>               <span class="c1">// wait for a second</span>
<span class="p">}</span></code></pre></figure>

<p>I got Newbie Hack‚Äôs code going within 3 minutes</p>

<p>I looked down at my breakout board, I had some ‚ÄúPBx‚Äù pins, so I figured I had a Port B.  I located pin PB0 (the the pin marked ‚Äú1‚Äù in the above image) and I threw my LED and resistor on it.</p>

<p><img src="../images/Fritz_1634_LED_img1.jpg" alt="" /></p>

<p>I uploaded the program and got this:</p>

<p><img src="../images/6rxg5.gif" alt="" /></p>

<p><strong>But the purpose of this journal is to <em>understand</em> what I‚Äôm doing</strong>, not just copy it. So, the following is an explanation to myself, in case I forget stuff.</p>

<p><strong>What‚Äôs Going on in the Blinkin LED Code</strong></p>

<p>Atmel chips are amazing. They are versatile little uCs and the way this versatility is utilized from programming is by changing <a href="http://en.wikipedia.org/wiki/Bit">bits</a> within a <a href="http://en.wikipedia.org/wiki/Byte">byte</a>.  For example, a pin can work as either a INPUT or OUPUT, but how does the chip know which one?  You change the Digital Direction Registry (DDR) Bit of the pin.  The DDR bit is a little switch that can be flipped either on or off through programming.  When it is off (0) the pin acts as an INPUT, when it is set on, it acts an OUTPUT.</p>

<p>Now, Atmel chips are divided into <strong>ports</strong>, and thee ports have 8 pins (or less).  This allows one byte to control alot of the functions of one port.</p>

<p>Newbie Hacks (NB) does a great job of explaining this.  He even draws out a picture;I like pictures.</p>

<p><img src="http://www.newbiehack.com../images/DDRB.JPG" alt="" /></p>

<p>I like to think in images, so I see each bit as an LED.  It makes sense, an LED has two-states ON/OFF; a bit has two states 0 or 1.  So, a byte for me is 8 LEDs numbered 0-7.</p>

<p><img src="../images/LED_Bitwise_2_bb.jpg" alt="" /></p>

<p>The above image could represent the following code:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">DDRB</span> <span class="o">=</span> <span class="mi">0</span><span class="n">B00000001</span><span class="p">;</span></code></pre></figure>

<p>The Atmel chips have different ports, which usually have an array of pins. So, the DDR stands for digital direction registry of port B.  Then, we assign a state to every pin on port B (PB0-PB7) by setting a bit to either 0 or 1. So, according to the image and our code, we are setting ports B1-7 as INPUTS (0 = INPUT) and PB0 as an OUTPUT.</p>

<p>But don‚Äôt be confused, the LED we have connected isn‚Äôt turned on yet.  The voltage on PB0 still equals 0.  But, we could now change the voltage from 0 to 5.  We do this by changing another registry.  The port state registry, PORTB.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">PORTB</span> <span class="o">=</span> <span class="mi">0</span><span class="n">B00000001</span><span class="p">;</span></code></pre></figure>

<p>Actually sets pin 0 (PB0) on port B to 5 volts.  The other pins are still set as inputs, so you can‚Äôt change the voltage.</p>

<p>That simple folks?  Well, we also have to insert a delay.  Delay‚Äôs are really just telling the uC how many cycles to do nothing.  There is some math involved that divides the clock speed to get the exact time delay you would like in finite-ish numbers.  This math is locked away as a function in the &lt;util/delay.h&gt;  file.  So, for our sake, it is a simple matter of adding:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">_delay_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span></code></pre></figure>

<p>This tells our Tiny to sit idle for half a second, then continue.  Also, there is a _delay_us() function that will delay microseconds.</p>

<p>Ok.  Here are my study-notes</p>

<p><strong>Note #1: Adjusting the Clock Fuse.</strong></p>

<p>I did have one modification I had to make to NH‚Äôs program.  He uploads his program using AVRDude.  Atmel Studio actually has libraries to specific to the Tiny1634, these are included when you setup your project.  One of these libraries require you tell the program how fast the CPU is going to be running.  The ATtiny‚Äôs have an internal 8mhz oscillator, but there is a <a href="http://www.ladyada.net/learn/avr/fuses.html">Atmel fuse</a> that is burned at the factory to divide 8mhz by 8, giving you a run speed of 1mhz.  I wanted to be working with my 1634 at the full 8mhz.</p>

<p>So, I went to <strong>Tools‚Äî&gt;Device Programming</strong>.  You then have to select your ‚ÄúTool,‚Äù for me the AVR ISP MKII; your device, ATtiny1634 for me; interface, ISP.  Then click ‚ÄúApply.‚Äù  Now, under ‚ÄúDevice Signature‚Äù click ‚ÄúRead.‚Äù  This should bring up the Device Programmer window.  Now, make sure you have your programmer wired to your chip correctly and you have a stable connection (might throw a .1uF radial capacitor between VCC and GND on the Tiny1634). Click on the ‚ÄúFuses‚Äù tab.</p>

<p><img src="../images/ATtiny1634_Lesson_1_img2.jpg" alt="" /></p>

<p>Uncheck the ‚ÄúCKDIV8.‚Äù  It is the fuse that does exactly what it says, divides the clock by 8, reducing the chip from 8mhz to 1mhz. <span style="text-decoration: underline;"><strong>Don‚Äôt change any other fuses at this time.</strong> Hit the ‚ÄúProgram‚Äù button.  This will set the fuse.  If all goes well we didn‚Äôt brick your chip.</span></p>

<p>While we are under the device programming window, click on the ‚ÄúMemories‚Äù tab.  This is where you will actually upload your compiled program onto the chip.  Here, if you click on the ellipsis you can select the code you would like to upload.  This ends in ‚Äú.elf‚Äù (unless you are using a chip besides an Tiny, then it‚Äôll end in .troll, hehe).  So, select your code and then hit ‚ÄúProgram.‚Äù</p>

<p><img src="../images/ATtiny1634_Lesson_1_img3.jpg" alt="" /></p>

<p>Now, Atmel Studio is setup to automatically program your code using the last selected devices whenever you hit ‚ÄúF5.‚Äù  Sadly, I found this rarely worked properly.  But I‚Äôm betting it‚Äôs because I have no decoupling capacitor‚Äìyes, I confirmed this.  <span style="text-decoration: line-through;">I put a 1uF radial capacitor between VCC and GND, now the ‚ÄúF5‚Äù programming works as expected. I‚Äôve no idea.  Seems to work if I manually program it though.  Shrug.</span></p>

<p>Ok.  Now we have our Tiny running at 8mhz, we will need to adjust this in our code.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define F_CPU 8000000 // AVR clock frequency in Hz, used by util/delay.h&lt;/pre&gt;</span></code></pre></figure>

<p>Here we are telling the program our chip is running at 8mhz (8,000,000 <a href="http://en.wikipedia.org/wiki/Hertz">hertz</a>).</p>

<p>After this, I uploaded the code and it ran just as I had hoped.  The LED would be on for half a second, then off for half a second.</p>

<p>Alright, a few other notes.</p>

<p><strong>Note #2: Pin shortcuts and <a href="http://en.wikipedia.org/wiki/Bitwise_operations_in_C">Bitwise Operators</a>.</strong></p>

<p>Bitwise operators are arithmetic operations that may be performed on binary numbers.  There are four main ones:</p>

<ol>
  <li><a href="http://en.wikipedia.org/wiki/Bitwise_operations_in_C#Bitwise_AND_.22.26.22">AND</a> (&amp;)</li>
  <li><a href="http://en.wikipedia.org/wiki/Bitwise_operations_in_C#Bitwise_OR_.22.7C.22">OR</a>(|)</li>
  <li><a href="http://en.wikipedia.org/wiki/Bitwise_operations_in_C#Bitwise_XOR_.22.5E.22">XOR</a> (^)</li>
  <li><a href="http://en.wikipedia.org/wiki/Bitwise_operations_in_C#Bitwise_NOT_.22.7E.22_.2F_One.27s_Complement_.28Unary.29">NOT</a> (~)</li>
</ol>

<p>I will not go into much detail on Bitwise Operators because Newbie Hacks does an excellent job explaining them.  And they are all over the internet.  But for our purposes, building robots, it is good to know what they look like and what they‚Äôll do to our bits (remember, your pins‚Äô output are controlled by bit registries).</p>

<p>So, I‚Äôll cover two that apply to our example and one bitwise helper: <strong>OR,</strong> <strong>XOR,</strong> and <strong>¬´</strong> (left shift).</p>

<p><strong>The OR operator:</strong></p>

<p>We learned that the following sets pin PB0 as an OUTPUT.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">DDRB</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000001</span><span class="p">;</span></code></pre></figure>

<p>But we can use the bitwise operator, OR, to do the same,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">DDRB</span> <span class="o">|=</span> <span class="mi">0</span><span class="n">b00000001</span><span class="p">;</span></code></pre></figure>

<p>The ‚Äú|=‚Äù is an abbreviated operation that represents the following,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">DDRB</span> <span class="o">=</span> <span class="n">DDRB</span> <span class="o">|</span> <span class="mi">0</span><span class="n">b0000001</span><span class="p">;</span></code></pre></figure>

<p>In English, ‚ÄúWhatever is in DDRB is equal to whatever is in DDRB <strong>OR</strong> 0b0000001.‚Äù</p>

<p>That looks like this,</p>

<p><img src="../images/LED_Bitwise_3_OR_bb.jpg" alt="" /></p>

<p>Bitwise operators, like OR‚Äôing, are done on the entire byte.  That is, each bit, 0-7, are OR‚Äôd, so you have to keep in mind the operation isn‚Äôt done <em>only</em> on the bit you want to change.  This is where truth tables come in.  Below is a table describing the output of the OR operation.</p>

<p><strong>OR (|)</strong></p>

<p><img src="../images/Bitwise_Operators_OR_2.jpg" alt="" /></p>

<p><strong>The Left Shift ¬´:</strong></p>

<p><strong>(NOTE: I originally made some mistakes regarding the left-shift operator;<a href="http://letsmakerobots.com/node/39996#comment-114517">6677 has given a very clear description of the left-shift operator</a> in the comments.)</strong></p>

<p>In electronics registers usually have a fixed width.  For example, the PORTB registry has the width of 8 bits (0-7).  The left-shift operator (¬´) allows you to address a specific bit in a registry, it does this by moving the bits in the registry to the left.  The registry itself stays at a fixed width, so when this happens the new places introduced are zero.  The bits that get shifted past the width of the registry get detroyed.  Going back to the PORTB registry, you could address a different pin besides PB0 by using a shift-left operator.  The left-shift operator allows us to quickly create a bit-mask from a byte.  In code, this looks like the following:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">PORTB</span> <span class="o">=</span> <span class="n">DDRB</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span></code></pre></figure>

<p>The above takes the binary number assigned in DDRB and OR‚Äôs it with a bit mask that is exactly the same, except the third pin, that pin is equal to 1.  Therefore, <strong>PORTB</strong> would look like this after the operation,</p>

<p><img src="../images/LED_Bitwise_ShiftLeft_bb.jpg" alt="" /></p>

<p>This seems more complex to me, but I understand it becomes very important when you start pulling apart the metal of an AVR.</p>

<p>One last thing, the &lt;avr/io.h&gt; contains defined pin constants.  So, this operation,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">DDRB</span> <span class="o">|=</span> <span class="mi">0</span><span class="n">b00000001</span><span class="p">;</span></code></pre></figure>

<p>Can be written like so,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">DDRB</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span></code></pre></figure>

<p>They do exactly the same thing‚Äìand <em>I guess</em> the latter is easier to read.  Pfft.</p>

<p><strong>The XOR Operator:</strong></p>

<p>The XOR (^) operator is much like the OR operation.  Except, if A and B are equal the result is 0.  They are not equal, the result is 1.  Here‚Äôs the XOR truth table.</p>

<p><strong>XOR (^)</strong></p>

<p><img src="../images/Bitwise_Operators_XOR.jpg" alt="" /></p>

<p>Going back to the LED example, here is the XOR operation.</p>

<p><img src="../images/LED_Bitwise_7_XOR_bb.jpg" alt="" /></p>

<p>We use the XOR operation to turn the LED off and on.  Since a XOR operation on a bit is basically going to set it to the opposite it is in.  Therefore, if it is 0 it becomes 1, if it is 1, it becomes 0.  This means we can actually shorten or blink code using the operation.</p>

<p>So, our simplified code for Blinkin LED is,</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define F_CPU 8000000    // AVR clock frequency in Hz, used by util/delay.h
#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DDRB</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000001</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">PORTB</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000001</span><span class="p">;</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
		<span class="n">PORTB</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000000</span><span class="p">;</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>And that‚Äôs it.  That is as far as I‚Äôve gotten.  Now, before I move forward I plan attempting to interface a <a href="http://www.ti.com/lit/ds/symlink/sn754410.pdf">SN754410</a> and two small motors.  I figure, we know how to perform digital pin control and this should allow use to control motor direction, even if we can‚Äôt yet control the speed.</p>

<p>Robot Application Note #1: <strong>SN754410 and ATtiny1634</strong></p>

<p>First thing to do is wire up the H-Bridge.</p>

<p><img src="../images/ATtiny1634_SN754410_7.jpg" alt="" /></p>

<p>You may notice we wired both ‚ÄúEN‚Äù pins to 5v, I don‚Äôt know how to generate PWM with AVR yet (but I hope to get there, so I‚Äôll revisit this).  Also, I used 5v as both my motor source and the Tiny1634 source.  The motors I used were <a href="http://www.ebay.com/itm/181121246372?ssPageName=STRK:MEWNX:IT&amp;_trksid=p3984.m1439.l2649">these little guys</a>.  I figured since the drop voltage of the SN754410 is around 1.4-2v then I‚Äôd be pretty close to the target voltage of my motors (5v - 1.4v = 3.6v).  I kept everything approximate to the Tiny‚Äôs voltage rating; I figured if I wired something wrong I‚Äôd be safer keeping the voltage sources low.</p>

<p>And good call, this is the wiring mess I ended up with‚Ä¶I thought I would start with one motor and move to two.</p>

<p><img src="../images/IMG_0388.jpg" alt="" /></p>

<p>I began thinking code.  I know the basics of the SN754410 and I wanted to be able to hit all the functions of its truth-table.</p>

<p><img src="../images/hbridge_labpinout.jpg" alt="" /></p>

<p>So, I figured all I needed to do was get two of my IO pins to go HIGH and LOW to turn one direction, then switch them to go opposite.  This reminded me of the XOR (^) operator, since it did exactly that, turn a bit to its opposite.  This is the same operator we used to blink the LED.  I ended up with the following code:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define F_CPU 8000000    // AVR clock frequency in Hz, used by util/delay.h
#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;
</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DDRB</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span> <span class="c1">//We set the LED pin to output.</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA1</span><span class="p">;</span> <span class="c1">//Setup motor A IO 1</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA2</span><span class="p">;</span> <span class="c1">//Setup motor A IO 2</span>

	<span class="n">PORTA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA1</span><span class="p">;</span> <span class="c1">//Set motor A IO 1 high.  Motor A IO 2 will default low.</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// "^=" changes the state of the bit to the opposite of its current.</span>
		<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>  <span class="c1">//LED ON/OFF.</span>
		<span class="n">PORTA</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA1</span><span class="p">;</span>  <span class="c1">//Motor A starts HIGH, this flips it low, or back again.</span>
		<span class="n">PORTA</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA2</span><span class="p">;</span>  <span class="c1">//Motor A starts LOW, this flips it high, or back again.</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This code moved my motor one direction, then the other.  But there was no pause between the changes of directions.  I pulled it a part pretty quick, since I‚Äôve generally had bad luck with instantaneous reversal of inductors.</p>

<p><a href="http://youtu.be/YVd9ZZdimIw"><img src="../images/Play_Tiny1634_One_Motor.jpg" alt="" /></a></p>

<p>Well, that wouldn‚Äôt do.  But I realized another problem.  The XOR operator would flip the the pins from high to low, and back again.  But how would I set <em>both</em> pins to low? Or both to high?  Now, in Arduino C it‚Äôs pretty easy, you just write digitalWrite(pin#, HIGH), but in AVR we are controlling bits.</p>

<p>I know I could accomplish this in long-hand, like so:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define F_CPU 8000000    // AVR clock frequency in Hz, used by util/delay.h
#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DDRB</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span> <span class="c1">//We set the LED pin to output.</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA1</span><span class="p">;</span> <span class="c1">//Setup motor A IO 1</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA2</span><span class="p">;</span> <span class="c1">//Setup motor A IO 2</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//This will set the pins high or low, but it does not maintain other pin states.</span>
		<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span> <span class="c1">//LED ON/OFF.</span>
		<span class="n">PORTA</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000010</span><span class="p">;</span>  <span class="c1">//This sets PINA1 HIGH, and PINA2 LOW.</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">1500</span><span class="p">);</span>	 <span class="c1">//Wait 1.5 seconds.</span>

		<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span> <span class="c1">//LED ON/OFF.</span>
		<span class="n">PORTA</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000000</span><span class="p">;</span>  <span class="c1">//This sets PINA1 LOW, and PINA2 LOW.</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">1500</span><span class="p">);</span>	 <span class="c1">//Wait 1.5 seconds.</span>

		<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>  <span class="c1">//LED ON/OFF.</span>
		<span class="n">PORTA</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000100</span><span class="p">;</span>  <span class="c1">//This sets PINA1 HIGH, and PINA2 LOW.</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">1500</span><span class="p">);</span>	 <span class="c1">//Wait 1.5 seconds.</span>

		<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>  <span class="c1">//LED ON/OFF.</span>
		<span class="n">PORTA</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b00000000</span><span class="p">;</span>  <span class="c1">//This sets PINA1 HIGH, and PINA2 LOW.</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">1500</span><span class="p">);</span>	 <span class="c1">//Wait 1.5 seconds.</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This gave me the output I wanted.  The motor would turn one direction for 1.5 seconds, then stop, turn the other way, then stop, and start over.  Like this:</p>

<p><a href="http://youtu.be/WAiDQo9F8Yk"><img src="../images/Play_Tiny1634_One_Motor.jpg" alt="" /></a></p>

<p>This code felt bloated to me.  And another problem was dawning: What if my LED was on PORTA?  That means I would need to keep track the state of three bits (1) bit controlling motor connection A, (2) bit controlling motor connection B, and (3) LED.  This means I would need to track 9 possible states (3 pins ^ 2 states = 9 pin states).  Now, I might be able to do this mentally, but it would be taxing, especially if my code is dynamically modifying the PORTA registry.  But what if all 8 pins were used? 8 pins ^ 2 sates = 64 pin states.  Ummm‚Ä¶no.  I can‚Äôt do it.</p>

<p>It hit me.  This is why bitmasks and bitwise operators are so important; <strong>they dynamically change the states of one bit, while preserving the states of the rest of the registry.</strong>  Nifty.</p>

<p>I spent some time with in Newbie Hack‚Äôs tutorial: <a href="http://www.newbiehack.com/MicrocontrollerLEDblink.aspx">MCU LED Blink</a> tutorial.  Specifically, <a href="http://youtu.be/GSuynyy5MTc?t=56s">the video there</a>.  In it he explains how to use bitwise operators and bit-masks to change the state of a pin while preserving all of the other pin states.</p>

<p>Now we‚Äôre cooking.</p>

<p>We already know the bitwise operator (and mask) to set one bit high: <strong>OR.</strong></p>

<p>The <strong>OR (|)</strong>operator sets the a pin HIGH:</p>

<p><img src="../images/LED_Bitwise_5_OR_bb.jpg" alt="" /></p>

<p>Sadly, clearing a bit while preserving the registry is <em>slightly</em> more complicated.  To clear a bit we still use a bitmask, but we use two operators: <strong>AND (&amp;)</strong> and <strong>NOT (~)</strong>.  Their truth-tables look like the following:</p>

<p><strong>AND (&amp;)</strong></p>

<p><img src="../images/Bitwise_Operators_AND_2_0.jpg" alt="" /></p>

<p><strong>NOT (~)</strong> is unlike the other operators, it‚Äôs simple.  It inverts the bit.  If 0, it becomes 1, if 1, it turns to 0.</p>

<p><img src="../images/Bitwise_Operators_NOT.jpg" alt="" /></p>

<p>Instead of immediately modifying the PORT state we actually modify our bitmask with the NOT operator.  This gives us the inverse mask (00000001 becomes 11111110).  We then AND (&amp;) the inverted mask with hte PORT‚Äôs original state to clear PIN0 while preserving the other bit‚Äôs state.  Here‚Äôs the LED example for <strong>NOT</strong> and <strong>AND</strong> operation to clear a bit:</p>

<p><img src="../images/LED_Bitwise_1_AND_NOT_bb_2.jpg" alt="" /></p>

<p>Ok.  I <em>could</em> wrap my head around this.  I developed the following code which did what I wanted:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define F_CPU 8000000    // AVR clock frequency in Hz, used by util/delay.h
#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DDRB</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span> <span class="c1">//We set the LED pin to output.</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA1</span><span class="p">;</span> <span class="c1">//Setup motor A IO 1</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA2</span><span class="p">;</span> <span class="c1">//Setup motor A IO 2</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//Sets motor input A LOW, B HIGH.</span>
		<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>		<span class="c1">//LED ON/OFF.</span>
		<span class="n">PORTA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA1</span><span class="p">;</span>		<span class="c1">//This sets PINA1 HIGH.</span>
		<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA2</span><span class="p">);</span>	<span class="c1">//This sets PINA2 LOW.</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">1500</span><span class="p">);</span>			<span class="c1">//Wait 1.5 seconds.</span>

		<span class="c1">//Sets both motor inputs to low.</span>
		<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>		<span class="c1">//LED ON/OFF.</span>
		<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA1</span><span class="p">);</span>	<span class="c1">//This sets PINA1 LOW.</span>
		<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA2</span><span class="p">);</span>	<span class="c1">//This sets PINA2 LOW.</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">1500</span><span class="p">);</span>			<span class="c1">//Wait 1.5 seconds.</span>

		<span class="c1">//Sets motor input A HIGH, B LOW.</span>
		<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>		<span class="c1">//LED ON/OFF.</span>
		<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA1</span><span class="p">);</span>	<span class="c1">//This sets PINA1 LOW.</span>
		<span class="n">PORTA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA2</span><span class="p">;</span>		<span class="c1">//This sets PINA2 HIGH.</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">1500</span><span class="p">);</span>			<span class="c1">//Wait 1.5 seconds.</span>

		<span class="c1">//Sets both motor inputs to low.</span>
		<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>		<span class="c1">//LED ON/OFF.</span>
		<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA1</span><span class="p">);</span>	<span class="c1">//This sets PINA1 LOW.</span>
		<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA2</span><span class="p">);</span>	<span class="c1">//This sets PINA2 LOW.</span>
		<span class="n">_delay_ms</span><span class="p">(</span><span class="mi">1500</span><span class="p">);</span>			<span class="c1">//Wait 1.5 seconds.</span>
		<span class="p">}</span>

<span class="p">}</span></code></pre></figure>

<p>Code to NOT a PIN looks like this <code class="highlighter-rouge">PORTA &amp;= ~ (1 &lt;&lt; PINA1);.</code> In plain English and in order of operation, ‚ÄúSet PORTA PIN1 to HIGH, create a bitmask of PORTA, then NOT that bitmask.  After, take the NOT‚Äôed bitmask and AND it with PORTA‚Äôs original state.‚Äù</p>

<p><strong>Whew.</strong> I‚Äôm not sure I follow that even after writing it.  But I understand it.  Really, <code class="highlighter-rouge">PORTA &amp;= ~ (1 &lt;&lt; PINA1) = Set PA1 LOW.</code></p>

<p>But this is good.  We now can dynamically change the state of one PIN without destroying the state of the other PINs on the same port.  Booyah!</p>

<p>Alright, let‚Äôs go for broke; now that I understand how to set pins HIGH or LOW, I wanted an easy way to control a motor with AVR.  I wrote five functions.  Four control the states of the motor (HH, LL, LH, HL) and one is a delay function that will accept a variable.  The functions can be called from the main loop.  Each one expects three parameters, two pin numbers and the number of milliseconds you wish the function to run.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define F_CPU 8000000    // AVR clock frequency in Hz, used by util/delay.h
#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;
</span>
<span class="kt">void</span> <span class="nf">delay_ms</span><span class="p">(</span><span class="kt">int</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//We make our own millisecond delay function because</span>
	<span class="c1">//the _delay_ms does not like dynamic variables.  Meaning</span>
	<span class="c1">//you cannot pass it a variable.  By making our own, we can.</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ms</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_delay_us</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>  <span class="c1">// one millisecond</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">forward</span><span class="p">(</span><span class="kt">int</span> <span class="n">motPinA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motPinB</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motorFireDuration</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//Sets motor input A LOW, B HIGH.</span>
	<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>		<span class="c1">//LED ON/OFF.</span>
	<span class="n">PORTA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinA</span><span class="p">;</span>		<span class="c1">//This sets PINA1 HIGH.</span>
	<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinB</span><span class="p">);</span>	<span class="c1">//This sets PINA2 LOW.</span>
	<span class="n">delay_ms</span><span class="p">(</span><span class="n">motorFireDuration</span><span class="p">);</span>			<span class="c1">//Wait 1.5 seconds.</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">backward</span><span class="p">(</span><span class="kt">int</span> <span class="n">motPinA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motPinB</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motorFireDuration</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//Sets motor input A HIGH, B LOW.</span>
	<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>		<span class="c1">//LED ON/OFF.</span>
	<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinA</span><span class="p">);</span>	<span class="c1">//This sets PINA1 LOW.</span>
	<span class="n">PORTA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinB</span><span class="p">;</span>		<span class="c1">//This sets PINA2 HIGH.</span>
	<span class="n">delay_ms</span><span class="p">(</span><span class="n">motorFireDuration</span><span class="p">);</span>			<span class="c1">//Wait 1.5 seconds.</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">coast</span><span class="p">(</span><span class="kt">int</span> <span class="n">motPinA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motPinB</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motorFireDuration</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//Sets both motor inputs to low.</span>
	<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>		<span class="c1">//LED ON/OFF.</span>
	<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinA</span><span class="p">);</span>	<span class="c1">//This sets PINA1 LOW.</span>
	<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinB</span><span class="p">);</span>	<span class="c1">//This sets PINA2 LOW.</span>
	<span class="n">delay_ms</span><span class="p">(</span><span class="n">motorFireDuration</span><span class="p">);</span>			<span class="c1">//Wait 1.5 seconds.</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">brake</span><span class="p">(</span><span class="kt">int</span> <span class="n">motPinA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motPinB</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motorFireDuration</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//Sets both motor inputs to HIGH.</span>
	<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>	<span class="c1">//LED ON/OFF.</span>
	<span class="n">PORTA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinA</span><span class="p">;</span>	<span class="c1">//This sets PINA1 HIGH.</span>
	<span class="n">PORTA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinB</span><span class="p">;</span>	<span class="c1">//This sets PINA2 HIGH.</span>
	<span class="n">delay_ms</span><span class="p">(</span><span class="n">motorFireDuration</span><span class="p">);</span>			<span class="c1">//Wait 1.5 seconds.</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">DDRB</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span> <span class="c1">//We set the LED pin to output.</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA1</span><span class="p">;</span> <span class="c1">//Setup motor A IO 1</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA2</span><span class="p">;</span> <span class="c1">//Setup motor A IO 2</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//This function spins the motor in one direction for X milliseconds. (L, H)</span>
		<span class="n">forward</span><span class="p">(</span><span class="n">PINA1</span><span class="p">,</span> <span class="n">PINA2</span><span class="p">,</span> <span class="mi">750</span><span class="p">);</span>
		<span class="c1">//This function lets the motor free spin for X milliseconds (L, L).</span>
		<span class="n">coast</span><span class="p">(</span><span class="n">PINA1</span><span class="p">,</span> <span class="n">PINA2</span><span class="p">,</span> <span class="mi">1500</span><span class="p">);</span>
		<span class="c1">//This function spins the motor in the other direction for X milliseconds. (H, L)</span>
		<span class="n">backward</span><span class="p">(</span><span class="n">PINA1</span><span class="p">,</span> <span class="n">PINA2</span><span class="p">,</span> <span class="mi">800</span><span class="p">);</span>
		<span class="c1">//This function brakes the motor for X milliseconds (H, H).</span>
		<span class="n">brake</span><span class="p">(</span><span class="n">PINA1</span><span class="p">,</span> <span class="n">PINA2</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span></code></pre></figure>

<p>Nifty, eh?  Now all we need to do is add a second motor and then we can pass the functions the second motor pins and we can use the same set of code to control both motors.  Aren‚Äôt we efficient!</p>

<p><strong>Some time later‚Ä¶</strong></p>

<p>Well, that didn‚Äôt not work as I wanted.  I‚Äôm tired and didn‚Äôt think through how the delay would work in the function.  The function would be called for motor A, but motor B wouldn‚Äôt be called until A was done.  Doh.</p>

<p>Yes, this could be rewritten a hundred ways to salvage it.  But! Right now I‚Äôm tired, so here‚Äôs our working code.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define F_CPU 8000000    // AVR clock frequency in Hz, used by util/delay.h
#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;
</span>
<span class="kt">void</span> <span class="nf">delay_ms</span><span class="p">(</span><span class="kt">int</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//We make our own millisecond delay function because</span>
	<span class="c1">//the _delay_ms does not like dynamic variables.  Meaning</span>
	<span class="c1">//you cannot pass it a variable.  By making our own, we can.</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ms</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_delay_us</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>  <span class="c1">// one millisecond</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">forward</span><span class="p">(</span><span class="kt">int</span> <span class="n">motPinA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motPinB</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//Sets motor input A LOW, B HIGH.</span>
	<span class="n">PORTA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinA</span><span class="p">;</span>		<span class="c1">//This sets PINA1 HIGH.</span>
	<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinB</span><span class="p">);</span>	<span class="c1">//This sets PINA2 LOW.</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">backward</span><span class="p">(</span><span class="kt">int</span> <span class="n">motPinA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motPinB</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//Sets motor input A HIGH, B LOW.</span>
	<span class="n">PORTB</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span>		<span class="c1">//LED ON/OFF.</span>
	<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinA</span><span class="p">);</span>	<span class="c1">//This sets PINA1 LOW.</span>
	<span class="n">PORTA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinB</span><span class="p">;</span>		<span class="c1">//This sets PINA2 HIGH.</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">coast</span><span class="p">(</span><span class="kt">int</span> <span class="n">motPinA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motPinB</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinA</span><span class="p">);</span>	<span class="c1">//This sets PINA1 LOW.</span>
	<span class="n">PORTA</span> <span class="o">&amp;=</span> <span class="o">~</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinB</span><span class="p">);</span>	<span class="c1">//This sets PINA2 LOW.</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">brake</span><span class="p">(</span><span class="kt">int</span> <span class="n">motPinA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">motPinB</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">//Sets both motor inputs to HIGH.</span>
	<span class="n">PORTA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinA</span><span class="p">;</span>	<span class="c1">//This sets PINA1 HIGH.</span>
	<span class="n">PORTA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">motPinB</span><span class="p">;</span>	<span class="c1">//This sets PINA2 HIGH.</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">DDRB</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB0</span><span class="p">;</span> <span class="c1">//We set the LED pin to output.</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA1</span><span class="p">;</span> <span class="c1">//Setup motor A IO 1</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINA2</span><span class="p">;</span> <span class="c1">//Setup motor A IO 2</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINB3</span><span class="p">;</span> <span class="c1">//Setup motor A IO 1</span>
	<span class="n">DDRA</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">PINC4</span><span class="p">;</span> <span class="c1">//Setup motor A IO 1</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//This function spins the motor in one direction for X milliseconds. (L, H)</span>
		<span class="n">forward</span><span class="p">(</span><span class="n">PINA1</span><span class="p">,</span> <span class="n">PINA2</span><span class="p">);</span>
		<span class="n">forward</span><span class="p">(</span><span class="n">PINA4</span><span class="p">,</span> <span class="n">PINA3</span><span class="p">);</span>
		<span class="n">delay_ms</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

		<span class="c1">//This function lets the motor free spin for X milliseconds (L, L).</span>
		<span class="n">coast</span><span class="p">(</span><span class="n">PINA1</span><span class="p">,</span> <span class="n">PINA2</span><span class="p">);</span>
		<span class="n">coast</span><span class="p">(</span><span class="n">PINA4</span><span class="p">,</span> <span class="n">PINA3</span><span class="p">);</span>
		<span class="n">delay_ms</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

		<span class="c1">//This function spins the motor in the other direction for X milliseconds. (H, L)</span>
		<span class="n">backward</span><span class="p">(</span><span class="n">PINA1</span><span class="p">,</span> <span class="n">PINA2</span><span class="p">);</span>
		<span class="n">backward</span><span class="p">(</span><span class="n">PINA4</span><span class="p">,</span> <span class="n">PINA3</span><span class="p">);</span>
		<span class="n">delay_ms</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

		<span class="c1">//This function brakes the motor for X milliseconds (H, H).</span>
		<span class="n">brake</span><span class="p">(</span><span class="n">PINA1</span><span class="p">,</span> <span class="n">PINA2</span><span class="p">);</span>
		<span class="n">brake</span><span class="p">(</span><span class="n">PINA4</span><span class="p">,</span> <span class="n">PINA3</span><span class="p">);</span>
		<span class="n">delay_ms</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span></code></pre></figure>

<p>Something else I realized.  I couldn‚Äôt wire motors to a different PORT (my schematic shows PB3 and PC0) since my functions call upon PORTA specifically.  Eh, oh well.  I‚Äôm tired.  I‚Äôm sure I‚Äôll clean this up over the next few days.</p>

<p>SO! Here‚Äôs what we ended with:</p>

<p><a href="http://youtu.be/N3AGEWW3jHU"><img src="../images/Play_Tiny1634_One_Motor.jpg" alt="" /></a></p>

<p>Next up! Inputs‚Ä¶ooooohhhh‚Ä¶</p>
:ET